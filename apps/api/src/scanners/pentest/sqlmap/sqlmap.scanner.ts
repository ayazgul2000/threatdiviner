import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as fs from 'fs/promises';
import * as path from 'path';
import { IScanner, ScanContext, ScanOutput, NormalizedFinding, Severity, Confidence } from '../../interfaces';
import { LocalExecutorService } from '../../execution';

@Injectable()
export class SqlmapScanner implements IScanner {
  readonly name = 'sqlmap';
  readonly version = '1.x';
  readonly supportedLanguages = ['web', 'api'];
  readonly outputFormat = 'json' as const;

  private readonly logger = new Logger(SqlmapScanner.name);
  private readonly sqlmapPath: string;

  constructor(
    private readonly executor: LocalExecutorService,
    private readonly configService: ConfigService,
  ) {
    this.sqlmapPath = this.configService.get('SQLMAP_PATH', 'sqlmap');
  }

  async isAvailable(): Promise<boolean> {
    return this.executor.isCommandAvailable(this.sqlmapPath);
  }

  async getVersion(): Promise<string> {
    // SQLMap's --version requires user input, use pip to get version
    try {
      const result = await this.executor.execute({
        command: 'pip',
        args: ['show', 'sqlmap'],
        cwd: process.cwd(),
        timeout: 5000,
      });
      const versionMatch = result.stdout.match(/Version:\s*([\d.]+)/);
      return versionMatch ? versionMatch[1] : '1.x';
    } catch {
      return '1.x';
    }
  }

  async scan(context: ScanContext): Promise<ScanOutput> {
    const outputDir = path.join(context.workDir, 'sqlmap-output');
    await fs.mkdir(outputDir, { recursive: true });

    // Get target URLs from config
    const targetUrls = context.config?.targetUrls as string[] || [];
    if (targetUrls.length === 0) {
      this.logger.warn('No target URLs configured for SQLMap scan');
      return {
        scanner: this.name,
        exitCode: 0,
        stdout: 'No target URLs configured',
        stderr: '',
        duration: 0,
        timedOut: false,
      };
    }

    // Create targets file
    const targetsFile = path.join(context.workDir, 'sqlmap-targets.txt');
    await fs.writeFile(targetsFile, targetUrls.join('\n'));

    const args = [
      '-m', targetsFile, // Multiple targets mode
      '--batch', // Non-interactive mode
      '--output-dir', outputDir,
      '--forms', // Auto-test forms
      '--crawl=2', // Crawl depth
      '--level=2', // Test level
      '--risk=1', // Risk level (1=safe)
      '--threads=4',
      '--timeout=30',
    ];

    // Add tamper scripts for WAF bypass if needed
    const tamperScripts = this.configService.get('SQLMAP_TAMPER', '');
    if (tamperScripts) {
      args.push('--tamper', tamperScripts);
    }

    const result = await this.executor.execute({
      command: this.sqlmapPath,
      args,
      cwd: context.workDir,
      timeout: context.timeout,
    });

    result.outputFile = outputDir;

    return result;
  }

  async parseOutput(output: ScanOutput): Promise<NormalizedFinding[]> {
    const findings: NormalizedFinding[] = [];

    if (!output.outputFile) {
      this.logger.warn('No output directory to parse');
      return findings;
    }

    try {
      // SQLMap creates a directory structure with results
      const outputDir = output.outputFile;
      const targetDirs = await fs.readdir(outputDir);

      for (const targetDir of targetDirs) {
        const targetPath = path.join(outputDir, targetDir);
        const stat = await fs.stat(targetPath);

        if (!stat.isDirectory()) continue;

        // Look for log file
        const logFile = path.join(targetPath, 'log');
        try {
          const logContent = await fs.readFile(logFile, 'utf-8');
          const parsedFindings = this.parseLogFile(logContent, targetDir);
          findings.push(...parsedFindings);
        } catch {
          // Log file may not exist if no vulnerabilities found
        }
      }
    } catch (error) {
      this.logger.error(`Failed to parse SQLMap output: ${error}`);
    }

    this.logger.log(`Parsed ${findings.length} SQLMap findings`);
    return findings;
  }

  private parseLogFile(logContent: string, target: string): NormalizedFinding[] {
    const findings: NormalizedFinding[] = [];
    const lines = logContent.split('\n');

    let currentParameter = '';
    let currentPayload = '';
    let currentTechnique = '';

    for (const line of lines) {
      // Parse parameter info
      if (line.includes('Parameter:')) {
        const match = line.match(/Parameter: (.+)/);
        if (match) currentParameter = match[1].trim();
      }

      // Parse injection type
      if (line.includes('Type:')) {
        const match = line.match(/Type: (.+)/);
        if (match) currentTechnique = match[1].trim();
      }

      // Parse payload
      if (line.includes('Payload:')) {
        const match = line.match(/Payload: (.+)/);
        if (match) currentPayload = match[1].trim();
      }

      // Detected vulnerability
      if (line.includes('is vulnerable') || line.includes('injectable')) {
        findings.push(this.createFinding(target, currentParameter, currentTechnique, currentPayload));
        currentParameter = '';
        currentPayload = '';
        currentTechnique = '';
      }
    }

    return findings;
  }

  private createFinding(
    target: string,
    parameter: string,
    technique: string,
    payload: string,
  ): NormalizedFinding {
    const fingerprint = this.generateFingerprint(target, parameter, technique);

    return {
      scanner: this.name,
      ruleId: `sqlmap-sqli-${technique.toLowerCase().replace(/\s+/g, '-')}`,
      severity: 'critical' as Severity,
      confidence: 'high' as Confidence,
      title: `SQL Injection in parameter: ${parameter}`,
      description: this.buildDescription(target, parameter, technique, payload),
      filePath: target,
      startLine: 0,
      cweIds: ['CWE-89'], // SQL Injection
      cveIds: [],
      owaspIds: ['A03:2021'], // Injection
      references: [
        'https://owasp.org/Top10/A03_2021-Injection/',
        'https://cwe.mitre.org/data/definitions/89.html',
      ],
      fix: {
        description: 'Use parameterized queries or prepared statements. Never concatenate user input directly into SQL queries.',
      },
      fingerprint,
      metadata: {
        parameter,
        technique,
        payload,
        target,
      },
    };
  }

  private buildDescription(target: string, parameter: string, technique: string, payload: string): string {
    let desc = `SQL Injection vulnerability detected in the "${parameter}" parameter on ${target}.\n\n`;
    desc += `**Injection Type:** ${technique || 'Unknown'}\n`;

    if (payload) {
      desc += `**Sample Payload:** \`${payload}\`\n`;
    }

    desc += '\nThis vulnerability allows an attacker to execute arbitrary SQL commands against the database, ';
    desc += 'potentially leading to data theft, data manipulation, or complete system compromise.';

    return desc;
  }

  private generateFingerprint(target: string, parameter: string, technique: string): string {
    const data = `${target}:${parameter}:${technique}`;
    let hash = 0;
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return `sqlmap-${Math.abs(hash).toString(16)}`;
  }
}
