import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as fs from 'fs/promises';
import * as path from 'path';
import { IScanner, ScanContext, ScanOutput, NormalizedFinding, Severity, Confidence, DiscoveredParam } from '../../interfaces';
import { LocalExecutorService } from '../../execution';

@Injectable()
export class SqlmapScanner implements IScanner {
  readonly name = 'sqlmap';
  readonly version = '1.x';
  readonly supportedLanguages = ['web', 'api'];
  readonly outputFormat = 'json' as const;

  private readonly logger = new Logger(SqlmapScanner.name);
  private readonly sqlmapPath: string;

  constructor(
    private readonly executor: LocalExecutorService,
    private readonly configService: ConfigService,
  ) {
    this.sqlmapPath = this.configService.get('SQLMAP_PATH', 'sqlmap');
  }

  async isAvailable(): Promise<boolean> {
    return this.executor.isCommandAvailable(this.sqlmapPath);
  }

  async getVersion(): Promise<string> {
    // SQLMap's --version requires user input, use pip to get version
    try {
      const result = await this.executor.execute({
        command: 'pip',
        args: ['show', 'sqlmap'],
        cwd: process.cwd(),
        timeout: 5000,
      });
      const versionMatch = result.stdout.match(/Version:\s*([\d.]+)/);
      return versionMatch ? versionMatch[1] : '1.x';
    } catch {
      return '1.x';
    }
  }

  async scan(context: ScanContext): Promise<ScanOutput> {
    const startTime = Date.now();
    const outputDir = path.join(context.workDir, 'sqlmap-output');
    await fs.mkdir(outputDir, { recursive: true });

    // Get discovered params from Katana (preferred - has specific injection points)
    const discoveredParams = context.config?.discoveredParams as DiscoveredParam[] || [];
    // Fallback to discovered URLs from DAST scanners (ZAP spider)
    const discoveredUrls = context.config?.discoveredUrls as string[] || [];
    const baseTargetUrls = context.config?.targetUrls as string[] || [];

    // Progress callback for real-time updates
    const onProgress = context.config?.onProgress as ((progress: { scanner: string; percent: number; current?: number; total?: number }) => void) | undefined;
    const onLog = context.config?.onLog as ((line: string, stream: 'stdout' | 'stderr') => void) | undefined;

    // Priority 1: Use discovered params from Katana (most accurate injection points)
    if (discoveredParams.length > 0) {
      this.logger.log(`SQLMap testing ${discoveredParams.length} discovered parameters from Katana`);
      if (onLog) onLog(`Testing ${discoveredParams.length} discovered parameters`, 'stdout');
      return this.scanDiscoveredParams(context, discoveredParams, outputDir, startTime, onProgress, onLog);
    }

    // Priority 2: Use discovered URLs with query parameters
    if (discoveredUrls.length > 0) {
      // Filter to only URLs with query params
      const urlsWithParams = discoveredUrls.filter(url => url.includes('?') && url.includes('='));
      if (urlsWithParams.length > 0) {
        this.logger.log(`SQLMap testing ${urlsWithParams.length} URLs with query parameters`);
        if (onLog) onLog(`Testing ${urlsWithParams.length} URLs with query parameters`, 'stdout');
        return this.scanDiscoveredUrls(context, urlsWithParams, outputDir, startTime, onProgress, onLog);
      }
    }

    // Priority 3: Crawl base URLs if no discovered endpoints
    if (baseTargetUrls.length === 0) {
      this.logger.warn('No target URLs configured for SQLMap scan');
      return {
        scanner: this.name,
        exitCode: 0,
        stdout: 'No target URLs configured',
        stderr: '',
        duration: Date.now() - startTime,
        timedOut: false,
      };
    }

    this.logger.log(`SQLMap crawling ${baseTargetUrls.length} base URLs (no discovered endpoints)`);
    if (onLog) onLog(`No params discovered, crawling ${baseTargetUrls.length} base URLs`, 'stdout');
    return this.scanWithCrawl(context, baseTargetUrls, outputDir, startTime, onProgress, onLog);
  }

  /**
   * Scan specific discovered parameters from Katana
   * This is the most efficient method as we know exactly which params to test
   */
  private async scanDiscoveredParams(
    context: ScanContext,
    params: DiscoveredParam[],
    outputDir: string,
    startTime: number,
    onProgress?: (progress: { scanner: string; percent: number; current?: number; total?: number }) => void,
    onLog?: (line: string, stream: 'stdout' | 'stderr') => void,
  ): Promise<ScanOutput> {
    const allStdout: string[] = [];
    const allStderr: string[] = [];

    // Get tamper scripts config
    const tamperScripts = this.configService.get('SQLMAP_TAMPER', '');

    // Group params by URL to reduce redundant requests
    const urlParamMap = new Map<string, string[]>();
    for (const param of params) {
      const existing = urlParamMap.get(param.url) || [];
      existing.push(param.name);
      urlParamMap.set(param.url, existing);
    }

    const entries = Array.from(urlParamMap.entries());
    this.logger.log(`SQLMap testing ${params.length} params across ${entries.length} URLs`);

    for (let i = 0; i < entries.length; i++) {
      const [url, paramNames] = entries[i];
      
      if (onLog) onLog(`[${i + 1}/${entries.length}] Testing ${paramNames.length} params on: ${url}`, 'stdout');
      if (onProgress) {
        onProgress({
          scanner: this.name,
          percent: Math.round(((i + 1) / entries.length) * 100),
          current: i + 1,
          total: entries.length,
        });
      }

      const args = [
        '-u', url,
        '-p', paramNames.join(','), // Test specific parameters only
        '--batch',
        '--output-dir', outputDir,
        '--level=2',
        '--risk=1',
        '--threads=4',
        '--timeout=30',
        '--smart',
      ];

      if (tamperScripts) {
        args.push('--tamper', tamperScripts);
      }

      try {
        const perUrlTimeout = Math.max(30000, Math.floor(context.timeout / entries.length));

        const result = await this.executor.execute({
          command: this.sqlmapPath,
          args,
          cwd: context.workDir,
          timeout: perUrlTimeout,
        });

        allStdout.push(`\n--- ${url} (params: ${paramNames.join(', ')}) ---\n${result.stdout}`);
        if (result.stderr) allStderr.push(result.stderr);

        if (result.stdout.includes('is vulnerable') || result.stdout.includes('injectable')) {
          this.logger.log(`Found SQL injection in: ${url} (params: ${paramNames.join(', ')})`);
          if (onLog) onLog(`VULNERABLE: ${url} - params: ${paramNames.join(', ')}`, 'stderr');
        }
      } catch (error) {
        const errMsg = error instanceof Error ? error.message : String(error);
        this.logger.warn(`SQLMap error on ${url}: ${errMsg}`);
        allStderr.push(`Error on ${url}: ${errMsg}`);
      }
    }

    return {
      scanner: this.name,
      exitCode: 0,
      stdout: allStdout.join('\n'),
      stderr: allStderr.join('\n'),
      outputFile: outputDir,
      duration: Date.now() - startTime,
      timedOut: false,
    };
  }

  /**
   * Scan discovered URLs with query parameters using -u flag for each URL
   * This is the preferred method when ZAP spider has found parameterized endpoints
   */
  private async scanDiscoveredUrls(
    context: ScanContext,
    urls: string[],
    outputDir: string,
    startTime: number,
    onProgress?: (progress: { scanner: string; percent: number; current?: number; total?: number }) => void,
    onLog?: (line: string, stream: 'stdout' | 'stderr') => void,
  ): Promise<ScanOutput> {
    this.logger.log(`SQLMap testing ${urls.length} discovered parameterized URLs`);

    const allStdout: string[] = [];
    const allStderr: string[] = [];

    // Get tamper scripts config
    const tamperScripts = this.configService.get('SQLMAP_TAMPER', '');

    // Test each URL individually with -u flag
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      
      if (onLog) onLog(`[${i + 1}/${urls.length}] Testing: ${url}`, 'stdout');
      if (onProgress) {
        onProgress({
          scanner: this.name,
          percent: Math.round(((i + 1) / urls.length) * 100),
          current: i + 1,
          total: urls.length,
        });
      }

      const args = [
        '-u', url, // Single URL with parameters
        '--batch', // Non-interactive mode
        '--output-dir', outputDir,
        '--level=2', // Test level (2 tests more parameters)
        '--risk=1', // Risk level (1=safe)
        '--threads=4',
        '--timeout=30',
        '--smart', // Smart mode - only test if injectable
      ];

      // Add tamper scripts for WAF bypass if configured
      if (tamperScripts) {
        args.push('--tamper', tamperScripts);
      }

      try {
        // Calculate per-URL timeout (distribute total timeout across URLs)
        const perUrlTimeout = Math.max(
          30000, // Minimum 30 seconds per URL
          Math.floor(context.timeout / urls.length),
        );

        const result = await this.executor.execute({
          command: this.sqlmapPath,
          args,
          cwd: context.workDir,
          timeout: perUrlTimeout,
        });

        allStdout.push(`\n--- ${url} ---\n${result.stdout}`);
        if (result.stderr) {
          allStderr.push(result.stderr);
        }

        // Check if vulnerabilities were found
        if (result.stdout.includes('is vulnerable') || result.stdout.includes('injectable')) {
          this.logger.log(`Found SQL injection in: ${url}`);
          if (onLog) onLog(`VULNERABLE: ${url}`, 'stderr');
        }
      } catch (error) {
        const errMsg = error instanceof Error ? error.message : String(error);
        this.logger.warn(`SQLMap error on ${url}: ${errMsg}`);
        allStderr.push(`Error on ${url}: ${errMsg}`);
      }
    }

    return {
      scanner: this.name,
      exitCode: 0,
      stdout: allStdout.join('\n'),
      stderr: allStderr.join('\n'),
      outputFile: outputDir,
      duration: Date.now() - startTime,
      timedOut: false,
    };
  }

  /**
   * Fallback: scan base URLs with crawling enabled
   * Used when no discovered URLs with parameters are available
   */
  private async scanWithCrawl(
    context: ScanContext,
    urls: string[],
    outputDir: string,
    _startTime: number,
    onProgress?: (progress: { scanner: string; percent: number }) => void,
    _onLog?: (line: string, stream: 'stdout' | 'stderr') => void,
  ): Promise<ScanOutput> {
    // Create targets file for bulk scanning
    const targetsFile = path.join(context.workDir, 'sqlmap-targets.txt');
    await fs.writeFile(targetsFile, urls.join('\n'));

    const args = [
      '-m', targetsFile, // Multiple targets mode
      '--batch', // Non-interactive mode
      '--output-dir', outputDir,
      '--forms', // Auto-test forms
      '--crawl=2', // Crawl depth to find parameters
      '--level=2', // Test level
      '--risk=1', // Risk level (1=safe)
      '--threads=4',
      '--timeout=30',
    ];

    // Add tamper scripts for WAF bypass if configured
    const tamperScripts = this.configService.get('SQLMAP_TAMPER', '');
    if (tamperScripts) {
      args.push('--tamper', tamperScripts);
    }

    if (onProgress) {
      onProgress({ scanner: this.name, percent: 10 });
    }

    const result = await this.executor.execute({
      command: this.sqlmapPath,
      args,
      cwd: context.workDir,
      timeout: context.timeout,
    });

    if (onProgress) {
      onProgress({ scanner: this.name, percent: 100 });
    }

    result.outputFile = outputDir;

    return result;
  }

  async parseOutput(output: ScanOutput): Promise<NormalizedFinding[]> {
    const findings: NormalizedFinding[] = [];

    if (!output.outputFile) {
      this.logger.warn('No output directory to parse');
      return findings;
    }

    try {
      // SQLMap creates a directory structure with results
      const outputDir = output.outputFile;
      const targetDirs = await fs.readdir(outputDir);

      for (const targetDir of targetDirs) {
        const targetPath = path.join(outputDir, targetDir);
        const stat = await fs.stat(targetPath);

        if (!stat.isDirectory()) continue;

        // Look for log file
        const logFile = path.join(targetPath, 'log');
        try {
          const logContent = await fs.readFile(logFile, 'utf-8');
          const parsedFindings = this.parseLogFile(logContent, targetDir);
          findings.push(...parsedFindings);
        } catch {
          // Log file may not exist if no vulnerabilities found
        }
      }
    } catch (error) {
      this.logger.error(`Failed to parse SQLMap output: ${error}`);
    }

    this.logger.log(`Parsed ${findings.length} SQLMap findings`);
    return findings;
  }

  private parseLogFile(logContent: string, target: string): NormalizedFinding[] {
    const findings: NormalizedFinding[] = [];
    const lines = logContent.split('\n');

    let currentParameter = '';
    let currentPayload = '';
    let currentTechnique = '';

    for (const line of lines) {
      // Parse parameter info
      if (line.includes('Parameter:')) {
        const match = line.match(/Parameter: (.+)/);
        if (match) currentParameter = match[1].trim();
      }

      // Parse injection type
      if (line.includes('Type:')) {
        const match = line.match(/Type: (.+)/);
        if (match) currentTechnique = match[1].trim();
      }

      // Parse payload
      if (line.includes('Payload:')) {
        const match = line.match(/Payload: (.+)/);
        if (match) currentPayload = match[1].trim();
      }

      // Detected vulnerability
      if (line.includes('is vulnerable') || line.includes('injectable')) {
        findings.push(this.createFinding(target, currentParameter, currentTechnique, currentPayload));
        currentParameter = '';
        currentPayload = '';
        currentTechnique = '';
      }
    }

    return findings;
  }

  private createFinding(
    target: string,
    parameter: string,
    technique: string,
    payload: string,
  ): NormalizedFinding {
    const fingerprint = this.generateFingerprint(target, parameter, technique);

    return {
      scanner: this.name,
      ruleId: `sqlmap-sqli-${technique.toLowerCase().replace(/\s+/g, '-')}`,
      severity: 'critical' as Severity,
      confidence: 'high' as Confidence,
      title: `SQL Injection in parameter: ${parameter}`,
      description: this.buildDescription(target, parameter, technique, payload),
      filePath: target,
      startLine: 0,
      cweIds: ['CWE-89'], // SQL Injection
      cveIds: [],
      owaspIds: ['A03:2021'], // Injection
      references: [
        'https://owasp.org/Top10/A03_2021-Injection/',
        'https://cwe.mitre.org/data/definitions/89.html',
      ],
      fix: {
        description: 'Use parameterized queries or prepared statements. Never concatenate user input directly into SQL queries.',
      },
      fingerprint,
      metadata: {
        parameter,
        technique,
        payload,
        target,
      },
    };
  }

  private buildDescription(target: string, parameter: string, technique: string, payload: string): string {
    let desc = `SQL Injection vulnerability detected in the "${parameter}" parameter on ${target}.\n\n`;
    desc += `**Injection Type:** ${technique || 'Unknown'}\n`;

    if (payload) {
      desc += `**Sample Payload:** \`${payload}\`\n`;
    }

    desc += '\nThis vulnerability allows an attacker to execute arbitrary SQL commands against the database, ';
    desc += 'potentially leading to data theft, data manipulation, or complete system compromise.';

    return desc;
  }

  private generateFingerprint(target: string, parameter: string, technique: string): string {
    const data = `${target}:${parameter}:${technique}`;
    let hash = 0;
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return `sqlmap-${Math.abs(hash).toString(16)}`;
  }
}
