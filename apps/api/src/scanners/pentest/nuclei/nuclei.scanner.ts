import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as fs from 'fs/promises';
import * as path from 'path';
import { IScanner, ScanContext, ScanOutput, NormalizedFinding, Severity, Confidence } from '../../interfaces';
import { LocalExecutorService, ScanProgress } from '../../execution';

/**
 * Nuclei stats JSON output structure (from -stats-json)
 */
interface NucleiStatsJson {
  templates?: string;       // "150"
  hosts?: string;           // "1"
  requests?: string;        // "2500"
  total?: string;           // "4500"
  percent?: string;         // "55"
  matched?: string;         // "12"
  errors?: string;          // "3"
  rps?: string;             // "148"
  elapsed?: string;         // "0:01:30"
}

interface NucleiResult {
  template: string;
  'template-id': string;
  'template-path': string;
  info: {
    name: string;
    author: string[];
    tags: string[];
    description?: string;
    reference?: string[];
    severity: string;
    classification?: {
      'cve-id'?: string[];
      'cwe-id'?: string[];
    };
  };
  type: string;
  host: string;
  matched: string;
  'extracted-results'?: string[];
  ip?: string;
  timestamp: string;
  'matcher-name'?: string;
  'matcher-status': boolean;
}

@Injectable()
export class NucleiScanner implements IScanner {
  readonly name = 'nuclei';
  readonly version = '3.x';
  readonly supportedLanguages = ['web', 'api', 'network'];
  readonly outputFormat = 'json' as const;

  private readonly logger = new Logger(NucleiScanner.name);
  private readonly nucleiPath: string;

  constructor(
    private readonly executor: LocalExecutorService,
    private readonly configService: ConfigService,
  ) {
    this.nucleiPath = this.configService.get('NUCLEI_PATH', 'C:/dev/nuclei/nuclei.exe');
  }

  async isAvailable(): Promise<boolean> {
    try {
      await fs.access(this.nucleiPath);
      return true;
    } catch {
      return false;
    }
  }

  async getVersion(): Promise<string> {
    try {
      const result = await this.executor.execute({
        command: this.nucleiPath,
        args: ['-version'],
        cwd: process.cwd(),
        timeout: 10000,
      });
      // Parse "Nuclei Engine Version: v3.3.7"
      const versionMatch = result.stdout.match(/Version:\s*v?([\d.]+)/);
      return versionMatch ? versionMatch[1] : '3.3.7';
    } catch {
      return '3.3.7';
    }
  }

  async scan(context: ScanContext): Promise<ScanOutput> {
    // Use forward slashes for Windows compatibility with shell: true
    const normalizePath = (p: string) => p.replace(/\\/g, '/');
    const outputFile = normalizePath(path.join(context.workDir, 'nuclei-results.jsonl'));

    const targetUrls = context.config?.targetUrls as string[] || [];
    if (targetUrls.length === 0) {
      this.logger.warn('No target URLs configured for Nuclei scan');
      return {
        scanner: this.name,
        exitCode: 0,
        stdout: 'No target URLs configured',
        stderr: '',
        duration: 0,
        timedOut: false,
      };
    }

    // Create targets file (normalize path for Windows shell compatibility)
    const targetsFile = normalizePath(path.join(context.workDir, 'nuclei-targets.txt'));
    await fs.writeFile(targetsFile, targetUrls.join('\n'));

    const args = [
      '-l', targetsFile,
      '-jsonl',
      '-o', outputFile,
      '-severity', 'critical,high,medium,low,info',
      '-timeout', '30',
      '-rate-limit', '50',
      '-bulk-size', '25',
      '-concurrency', '10',
      '-stats',                // Enable stats output for progress tracking
      '-stats-json',           // Get stats in JSON format for parsing
      '-stats-interval', '3',  // Update stats every 3 seconds
    ];

    // Use specific templates if configured
    const templates = this.configService.get('NUCLEI_TEMPLATES', '');
    if (templates) {
      args.push('-t', templates);
    }

    // Get callbacks from context config
    const onProgress = context.config?.onProgress as ((progress: ScanProgress) => void) | undefined;
    const onLog = context.config?.onLog as ((line: string, stream: 'stdout' | 'stderr') => void) | undefined;

    // Parse nuclei stats JSON from stdout
    const onStdout = (line: string) => {
      // Stream log line to frontend
      if (onLog) {
        onLog(line, 'stdout');
      }

      // Parse stats JSON line (from -stats-json)
      // Format: {"templates":"150","hosts":"1","requests":"2500","total":"4500","percent":"55","matched":"12","errors":"3"}
      if (line.startsWith('{') && line.includes('"templates"')) {
        try {
          const stats: NucleiStatsJson = JSON.parse(line);
          const percent = parseInt(stats.percent || '0', 10);
          this.logger.log(`Nuclei progress: ${percent}% (${stats.requests}/${stats.total} requests, ${stats.matched} matched)`);

          if (onProgress) {
            onProgress({
              scanner: this.name,
              percent,
            });
          }
        } catch {
          // Not valid JSON stats line
        }
      }
    };

    // Parse nuclei stderr for stats JSON and fallback text progress
    const onStderr = (line: string) => {
      if (onLog) {
        onLog(line, 'stderr');
      }

      // Parse stats JSON line (from -stats-json) - nuclei outputs this to stderr
      if (line.startsWith('{') && line.includes('"templates"')) {
        try {
          const stats: NucleiStatsJson = JSON.parse(line);
          const percent = parseInt(stats.percent || '0', 10);
          this.logger.log(`Nuclei progress: ${percent}% (${stats.requests}/${stats.total} requests, ${stats.matched} matched)`);

          if (onProgress) {
            onProgress({
              scanner: this.name,
              percent,
            });
          }
        } catch {
          // Not valid JSON stats
        }
      }

      // Fallback: Parse text stats line: [INF] [0:00:30] | Templates: 150 | Hosts: 1 | RPS: 148 | Matched: 3 | Errors: 0 | Requests: 2500/4500 (55%)
      const statsMatch = line.match(/Requests:\s*(\d+)\/(\d+)\s*\((\d+)%\)/);
      if (statsMatch && onProgress) {
        const [, , , percent] = statsMatch;
        onProgress({
          scanner: this.name,
          percent: parseInt(percent, 10),
        });
      }
    };

    // Emit initial progress event
    if (onProgress) {
      this.logger.log('Emitting initial progress: 0%');
      onProgress({
        scanner: this.name,
        percent: 0,
      });
    }

    const result = await this.executor.execute({
      command: this.nucleiPath,
      args,
      cwd: context.workDir,
      timeout: context.timeout,
      onStdout,
      onStderr,
      scanId: context.scanId, // For process tracking/cancellation
    });

    try {
      await fs.access(outputFile);
      result.outputFile = outputFile;
    } catch {
      this.logger.warn('Nuclei output file not created');
    }

    return result;
  }

  async parseOutput(output: ScanOutput): Promise<NormalizedFinding[]> {
    if (!output.outputFile) {
      this.logger.warn('No output file to parse');
      return [];
    }

    const findings: NormalizedFinding[] = [];

    try {
      const content = await fs.readFile(output.outputFile, 'utf-8');
      const lines = content.trim().split('\n').filter(Boolean);

      for (const line of lines) {
        try {
          const result: NucleiResult = JSON.parse(line);
          const finding = this.convertResult(result);
          if (finding) {
            findings.push(finding);
          }
        } catch {
          // Skip invalid JSON lines
        }
      }

      this.logger.log(`Parsed ${findings.length} Nuclei findings`);
    } catch (error) {
      this.logger.error(`Failed to parse Nuclei output: ${error}`);
    }

    return findings;
  }

  private convertResult(result: NucleiResult): NormalizedFinding | null {
    const severity = this.mapSeverity(result.info.severity);
    const fingerprint = this.generateFingerprint(result['template-id'], result.host);

    return {
      scanner: this.name,
      ruleId: `nuclei-${result['template-id']}`,
      severity,
      confidence: 'high' as Confidence,
      title: result.info.name,
      description: this.buildDescription(result),
      filePath: result.host,
      startLine: 0,
      cweIds: result.info.classification?.['cwe-id'] || [],
      cveIds: result.info.classification?.['cve-id'] || [],
      owaspIds: this.extractOwaspIds(result.info.tags),
      references: result.info.reference || [],
      fix: {
        description: this.suggestFix(result),
      },
      fingerprint,
      metadata: {
        templateId: result['template-id'],
        templatePath: result['template-path'],
        matched: result.matched,
        matcherName: result['matcher-name'],
        type: result.type,
        tags: result.info.tags,
        extractedResults: result['extracted-results'],
      },
    };
  }

  private mapSeverity(severity: string): Severity {
    const severityMap: Record<string, Severity> = {
      critical: 'critical',
      high: 'high',
      medium: 'medium',
      low: 'low',
      info: 'info',
    };
    return severityMap[severity.toLowerCase()] || 'info';
  }

  private buildDescription(result: NucleiResult): string {
    let desc = result.info.description || `Nuclei detected: ${result.info.name}`;
    desc += `\n\n**Target:** ${result.host}`;
    desc += `\n**Matched:** ${result.matched}`;

    if (result['matcher-name']) {
      desc += `\n**Matcher:** ${result['matcher-name']}`;
    }

    if (result['extracted-results'] && result['extracted-results'].length > 0) {
      desc += `\n**Extracted Data:**\n${result['extracted-results'].slice(0, 3).join('\n')}`;
    }

    return desc;
  }

  private extractOwaspIds(tags: string[]): string[] {
    const owaspIds: string[] = [];
    const owaspMap: Record<string, string> = {
      injection: 'A03:2021',
      xss: 'A03:2021',
      sqli: 'A03:2021',
      auth: 'A07:2021',
      misconfig: 'A05:2021',
      exposure: 'A01:2021',
      ssrf: 'A10:2021',
      lfi: 'A01:2021',
      rce: 'A03:2021',
    };

    for (const tag of tags) {
      const tagLower = tag.toLowerCase();
      for (const [key, value] of Object.entries(owaspMap)) {
        if (tagLower.includes(key)) {
          if (!owaspIds.includes(value)) {
            owaspIds.push(value);
          }
        }
      }
    }

    return owaspIds;
  }

  private suggestFix(result: NucleiResult): string {
    const tags = result.info.tags.map(t => t.toLowerCase());
    const name = result.info.name.toLowerCase();

    // Injection vulnerabilities
    if (tags.includes('sqli') || name.includes('sql injection')) {
      return 'Use parameterized queries or prepared statements. Never concatenate user input into SQL queries. Implement input validation and use ORM frameworks.';
    }

    if (tags.includes('xss') || name.includes('cross-site scripting')) {
      return 'Encode all user input before rendering. Use Content-Security-Policy headers. Apply context-aware output encoding (HTML, JS, URL, CSS).';
    }

    if (tags.includes('rce') || name.includes('remote code execution')) {
      return 'Never pass user input directly to shell commands. Use safe APIs that avoid shell interpretation. Apply strict input validation with allowlists.';
    }

    if (tags.includes('lfi') || tags.includes('rfi') || name.includes('file inclusion')) {
      return 'Never use user input in file paths. Use allowlists for permitted files. Disable remote file inclusion in PHP.';
    }

    if (tags.includes('ssrf') || name.includes('server-side request')) {
      return 'Validate and sanitize all URLs. Use allowlists for permitted domains. Block access to internal IP ranges (127.0.0.1, 10.x, 172.16-31.x, 192.168.x).';
    }

    if (tags.includes('ssti') || name.includes('template injection')) {
      return 'Never pass user input directly to template engines. Use sandboxed template execution. Apply strict input validation.';
    }

    // Authentication & Access
    if (tags.includes('default-login') || name.includes('default credentials')) {
      return 'Change default credentials immediately. Enforce strong password policies. Implement account lockout after failed attempts.';
    }

    if (tags.includes('auth-bypass') || name.includes('authentication bypass')) {
      return 'Review authentication logic for flaws. Implement proper session management. Use secure authentication frameworks with MFA.';
    }

    if (tags.includes('token') || name.includes('token')) {
      return 'Use cryptographically secure tokens. Implement proper token expiration. Store tokens securely (HttpOnly cookies for web).';
    }

    // Information Disclosure
    if (tags.includes('exposure') || tags.includes('disclosure')) {
      return 'Remove or restrict access to the exposed resource. Move sensitive files outside web root. Implement proper access controls.';
    }

    if (tags.includes('config') || name.includes('configuration')) {
      return 'Ensure config files are not web-accessible. Move sensitive config outside web root. Use environment variables for secrets.';
    }

    if (name.includes('.git') || name.includes('.svn') || name.includes('.env')) {
      return 'Block access to version control and environment files in server config. Remove from web root if present.';
    }

    // Misconfigurations
    if (tags.includes('misconfig')) {
      return 'Review server configuration against security benchmarks (CIS, OWASP). Apply principle of least privilege. Disable unnecessary features.';
    }

    if (tags.includes('cors') || name.includes('cors')) {
      return 'Configure strict CORS policy. Avoid Access-Control-Allow-Origin: *. Validate Origin header against allowlist.';
    }

    if (name.includes('directory listing')) {
      return 'Disable directory listing: Apache (Options -Indexes), Nginx (autoindex off), IIS (disable Directory Browsing).';
    }

    // CVE-specific
    if (tags.some(t => t.includes('cve'))) {
      const cves = result.info.classification?.['cve-id'] || [];
      if (cves.length > 0) {
        return `Apply security patches for ${cves.join(', ')}. Check vendor advisories for specific remediation steps. Update to the latest patched version.`;
      }
      return 'Apply the security patch for the identified CVE. Check NVD for specific remediation guidance. Update to the latest patched version.';
    }

    // Technology-specific
    if (tags.includes('wordpress') || name.includes('wordpress')) {
      return 'Update WordPress core, themes, and plugins to latest versions. Remove unused plugins. Use security plugins like Wordfence.';
    }

    if (tags.includes('apache') || name.includes('apache')) {
      return 'Update Apache to latest version. Review and harden configuration. Disable unnecessary modules.';
    }

    if (tags.includes('nginx') || name.includes('nginx')) {
      return 'Update Nginx to latest version. Review and harden configuration. Disable unnecessary features.';
    }

    // Fallback with context
    const fixes: string[] = [];
    if (result.info.reference && result.info.reference.length > 0) {
      fixes.push('Consult the referenced advisories for specific remediation steps.');
    }
    if (result['template-id']) {
      fixes.push(`Review Nuclei template ${result['template-id']} for detailed vulnerability information.`);
    }
    fixes.push('Apply security updates and review configuration against best practices.');

    return fixes.join(' ');
  }

  private generateFingerprint(templateId: string, host: string): string {
    const data = `${templateId}:${host}`;
    let hash = 0;
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return `nuclei-${Math.abs(hash).toString(16)}`;
  }
}
