import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as fs from 'fs/promises';
import * as path from 'path';
import { IScanner, ScanContext, ScanOutput, NormalizedFinding, Severity, Confidence } from '../../interfaces';
import { LocalExecutorService } from '../../execution';

interface SSLyzeServerScanResult {
  server_location: {
    hostname: string;
    port: number;
  };
  scan_result?: {
    certificate_info?: {
      certificate_deployments?: Array<{
        verified_certificate_chain?: Array<{
          subject: { rfc4514_string: string };
          not_valid_before: string;
          not_valid_after: string;
          signature_algorithm_oid: string;
        }>;
        leaf_certificate_subject_matches_hostname: boolean;
        received_chain_has_valid_order: boolean;
      }>;
    };
    ssl_2_0_cipher_suites?: {
      is_protocol_server_available: boolean;
    };
    ssl_3_0_cipher_suites?: {
      is_protocol_server_available: boolean;
    };
    tls_1_0_cipher_suites?: {
      is_protocol_server_available: boolean;
      accepted_cipher_suites?: Array<{ cipher_suite: { name: string } }>;
    };
    tls_1_1_cipher_suites?: {
      is_protocol_server_available: boolean;
    };
    tls_1_2_cipher_suites?: {
      is_protocol_server_available: boolean;
      accepted_cipher_suites?: Array<{ cipher_suite: { name: string } }>;
    };
    tls_1_3_cipher_suites?: {
      is_protocol_server_available: boolean;
    };
    heartbleed?: {
      is_vulnerable_to_heartbleed: boolean;
    };
    robot?: {
      robot_result: string;
    };
  };
}

interface SSLyzeOutput {
  server_scan_results: SSLyzeServerScanResult[];
}

@Injectable()
export class SSLyzeScanner implements IScanner {
  readonly name = 'sslyze';
  readonly version = '5.x';
  readonly supportedLanguages = ['network', 'web'];
  readonly outputFormat = 'json' as const;

  private readonly logger = new Logger(SSLyzeScanner.name);
  private readonly sslyzePath: string;

  constructor(
    private readonly executor: LocalExecutorService,
    private readonly configService: ConfigService,
  ) {
    this.sslyzePath = this.configService.get('SSLYZE_PATH', 'sslyze');
  }

  async isAvailable(): Promise<boolean> {
    return this.executor.isCommandAvailable(this.sslyzePath);
  }

  async getVersion(): Promise<string> {
    // SSLyze doesn't have a --version flag, return installed version
    try {
      const result = await this.executor.execute({
        command: 'pip',
        args: ['show', 'sslyze'],
        cwd: process.cwd(),
        timeout: 5000,
      });
      const versionMatch = result.stdout.match(/Version:\s*([\d.]+)/);
      return versionMatch ? versionMatch[1] : '6.x';
    } catch {
      return '6.x';
    }
  }

  async scan(context: ScanContext): Promise<ScanOutput> {
    const outputFile = path.join(context.workDir, 'sslyze-results.json');

    // Get target URLs/hosts from config
    const targetUrls = context.config?.targetUrls as string[] || [];
    if (targetUrls.length === 0) {
      this.logger.warn('No target URLs configured for SSLyze scan');
      return {
        scanner: this.name,
        exitCode: 0,
        stdout: 'No target URLs configured',
        stderr: '',
        duration: 0,
        timedOut: false,
      };
    }

    // Extract hostnames from URLs
    const hosts = targetUrls.map(url => {
      try {
        const parsed = new URL(url);
        return parsed.host;
      } catch {
        return url; // Assume it's already a host:port format
      }
    });

    const args = [
      '--json_out', outputFile,
      '--heartbleed', // Check for Heartbleed
      '--robot', // Check for ROBOT attack
      '--certinfo', // Certificate info
      '--tlsv1', // Check TLS 1.0
      '--tlsv1_1', // Check TLS 1.1
      '--tlsv1_2', // Check TLS 1.2
      '--tlsv1_3', // Check TLS 1.3
      '--sslv2', // Check SSL 2.0
      '--sslv3', // Check SSL 3.0
      ...hosts,
    ];

    const result = await this.executor.execute({
      command: this.sslyzePath,
      args,
      cwd: context.workDir,
      timeout: context.timeout,
    });

    // Check if output file was created
    try {
      await fs.access(outputFile);
      result.outputFile = outputFile;
    } catch {
      this.logger.warn('SSLyze output file not created');
    }

    return result;
  }

  async parseOutput(output: ScanOutput): Promise<NormalizedFinding[]> {
    if (!output.outputFile) {
      this.logger.warn('No output file to parse');
      return [];
    }

    try {
      const content = await fs.readFile(output.outputFile, 'utf-8');
      const results: SSLyzeOutput = JSON.parse(content);
      const findings: NormalizedFinding[] = [];

      for (const serverResult of results.server_scan_results || []) {
        const host = `${serverResult.server_location.hostname}:${serverResult.server_location.port}`;
        const scanResult = serverResult.scan_result;

        if (!scanResult) continue;

        // Check for deprecated protocols
        if (scanResult.ssl_2_0_cipher_suites?.is_protocol_server_available) {
          findings.push(this.createProtocolFinding(host, 'SSL 2.0', 'critical'));
        }

        if (scanResult.ssl_3_0_cipher_suites?.is_protocol_server_available) {
          findings.push(this.createProtocolFinding(host, 'SSL 3.0', 'critical'));
        }

        if (scanResult.tls_1_0_cipher_suites?.is_protocol_server_available) {
          findings.push(this.createProtocolFinding(host, 'TLS 1.0', 'high'));
        }

        if (scanResult.tls_1_1_cipher_suites?.is_protocol_server_available) {
          findings.push(this.createProtocolFinding(host, 'TLS 1.1', 'medium'));
        }

        // Check for Heartbleed
        if (scanResult.heartbleed?.is_vulnerable_to_heartbleed) {
          findings.push(this.createHeartbleedFinding(host));
        }

        // Check for ROBOT attack
        if (scanResult.robot?.robot_result && scanResult.robot.robot_result !== 'NOT_VULNERABLE_NO_ORACLE') {
          findings.push(this.createRobotFinding(host, scanResult.robot.robot_result));
        }

        // Check certificate issues
        const certInfo = scanResult.certificate_info?.certificate_deployments?.[0];
        if (certInfo) {
          if (!certInfo.leaf_certificate_subject_matches_hostname) {
            findings.push(this.createCertMismatchFinding(host));
          }

          // Check for expired certificate
          const leafCert = certInfo.verified_certificate_chain?.[0];
          if (leafCert) {
            const notAfter = new Date(leafCert.not_valid_after);
            if (notAfter < new Date()) {
              findings.push(this.createExpiredCertFinding(host, notAfter));
            }
          }
        }

        // Check for weak cipher suites
        const weakCiphers = this.findWeakCiphers(scanResult);
        if (weakCiphers.length > 0) {
          findings.push(this.createWeakCipherFinding(host, weakCiphers));
        }
      }

      this.logger.log(`Parsed ${findings.length} SSLyze findings`);
      return findings;
    } catch (error) {
      this.logger.error(`Failed to parse SSLyze output: ${error}`);
      return [];
    }
  }

  private findWeakCiphers(scanResult: SSLyzeServerScanResult['scan_result']): string[] {
    const weakCiphers: string[] = [];
    const weakPatterns = ['RC4', 'DES', 'MD5', 'NULL', 'EXPORT', 'anon'];

    const allCiphers = [
      ...(scanResult?.tls_1_0_cipher_suites?.accepted_cipher_suites || []),
      ...(scanResult?.tls_1_2_cipher_suites?.accepted_cipher_suites || []),
    ];

    for (const cipher of allCiphers) {
      const name = cipher.cipher_suite.name;
      if (weakPatterns.some(pattern => name.includes(pattern))) {
        weakCiphers.push(name);
      }
    }

    return weakCiphers;
  }

  private createProtocolFinding(host: string, protocol: string, severity: Severity): NormalizedFinding {
    return {
      scanner: this.name,
      ruleId: `sslyze-deprecated-${protocol.toLowerCase().replace(/\s+/g, '-')}`,
      severity,
      confidence: 'high' as Confidence,
      title: `Deprecated ${protocol} Protocol Enabled`,
      description: `The server ${host} supports the deprecated ${protocol} protocol. This protocol has known security vulnerabilities and should be disabled.`,
      filePath: host,
      startLine: 0,
      cweIds: ['CWE-326'], // Inadequate Encryption Strength
      cveIds: protocol === 'SSL 3.0' ? ['CVE-2014-3566'] : [], // POODLE
      owaspIds: ['A02:2021'], // Cryptographic Failures
      references: [
        'https://owasp.org/Top10/A02_2021-Cryptographic_Failures/',
      ],
      fix: {
        description: `Disable ${protocol} and only allow TLS 1.2 and TLS 1.3.`,
      },
      fingerprint: this.generateFingerprint(host, `deprecated-${protocol}`),
      metadata: { protocol, host },
    };
  }

  private createHeartbleedFinding(host: string): NormalizedFinding {
    return {
      scanner: this.name,
      ruleId: 'sslyze-heartbleed',
      severity: 'critical' as Severity,
      confidence: 'high' as Confidence,
      title: 'Heartbleed Vulnerability (CVE-2014-0160)',
      description: `The server ${host} is vulnerable to the Heartbleed bug, which allows attackers to read sensitive memory contents including private keys and session data.`,
      filePath: host,
      startLine: 0,
      cweIds: ['CWE-126'], // Buffer Over-read
      cveIds: ['CVE-2014-0160'],
      owaspIds: ['A02:2021'],
      references: [
        'https://heartbleed.com/',
        'https://nvd.nist.gov/vuln/detail/CVE-2014-0160',
      ],
      fix: {
        description: 'Update OpenSSL to a patched version (1.0.1g or later).',
      },
      fingerprint: this.generateFingerprint(host, 'heartbleed'),
      metadata: { host },
    };
  }

  private createRobotFinding(host: string, result: string): NormalizedFinding {
    return {
      scanner: this.name,
      ruleId: 'sslyze-robot',
      severity: 'high' as Severity,
      confidence: 'high' as Confidence,
      title: 'ROBOT Attack Vulnerability',
      description: `The server ${host} may be vulnerable to the ROBOT attack (Return Of Bleichenbacher's Oracle Threat). Result: ${result}`,
      filePath: host,
      startLine: 0,
      cweIds: ['CWE-203'], // Information Exposure Through Discrepancy
      cveIds: ['CVE-2017-13099'],
      owaspIds: ['A02:2021'],
      references: [
        'https://robotattack.org/',
      ],
      fix: {
        description: 'Disable RSA key exchange or update the TLS implementation.',
      },
      fingerprint: this.generateFingerprint(host, 'robot'),
      metadata: { host, result },
    };
  }

  private createCertMismatchFinding(host: string): NormalizedFinding {
    return {
      scanner: this.name,
      ruleId: 'sslyze-cert-mismatch',
      severity: 'medium' as Severity,
      confidence: 'high' as Confidence,
      title: 'Certificate Hostname Mismatch',
      description: `The SSL/TLS certificate for ${host} does not match the server hostname. This may indicate a misconfiguration or MITM attack.`,
      filePath: host,
      startLine: 0,
      cweIds: ['CWE-295'], // Improper Certificate Validation
      cveIds: [],
      owaspIds: ['A07:2021'],
      references: [],
      fix: {
        description: 'Obtain a certificate that matches the server hostname or configure the correct certificate.',
      },
      fingerprint: this.generateFingerprint(host, 'cert-mismatch'),
      metadata: { host },
    };
  }

  private createExpiredCertFinding(host: string, expiredAt: Date): NormalizedFinding {
    return {
      scanner: this.name,
      ruleId: 'sslyze-cert-expired',
      severity: 'high' as Severity,
      confidence: 'high' as Confidence,
      title: 'Expired SSL/TLS Certificate',
      description: `The SSL/TLS certificate for ${host} expired on ${expiredAt.toISOString()}. Expired certificates cause browser warnings and indicate poor security practices.`,
      filePath: host,
      startLine: 0,
      cweIds: ['CWE-298'], // Improper Validation of Certificate Expiration
      cveIds: [],
      owaspIds: ['A07:2021'],
      references: [],
      fix: {
        description: 'Renew the SSL/TLS certificate immediately.',
      },
      fingerprint: this.generateFingerprint(host, 'cert-expired'),
      metadata: { host, expiredAt: expiredAt.toISOString() },
    };
  }

  private createWeakCipherFinding(host: string, ciphers: string[]): NormalizedFinding {
    return {
      scanner: this.name,
      ruleId: 'sslyze-weak-ciphers',
      severity: 'medium' as Severity,
      confidence: 'high' as Confidence,
      title: 'Weak Cipher Suites Enabled',
      description: `The server ${host} supports weak cipher suites: ${ciphers.slice(0, 5).join(', ')}${ciphers.length > 5 ? ` and ${ciphers.length - 5} more` : ''}.`,
      filePath: host,
      startLine: 0,
      cweIds: ['CWE-327'], // Use of a Broken or Risky Cryptographic Algorithm
      cveIds: [],
      owaspIds: ['A02:2021'],
      references: [],
      fix: {
        description: 'Disable weak cipher suites and only allow strong, modern ciphers.',
      },
      fingerprint: this.generateFingerprint(host, 'weak-ciphers'),
      metadata: { host, weakCiphers: ciphers },
    };
  }

  private generateFingerprint(host: string, issue: string): string {
    const data = `${host}:${issue}`;
    let hash = 0;
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return `sslyze-${Math.abs(hash).toString(16)}`;
  }
}
