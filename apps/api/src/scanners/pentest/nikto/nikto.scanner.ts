import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as fs from 'fs/promises';
import * as path from 'path';
import { IScanner, ScanContext, ScanOutput, NormalizedFinding, Severity, Confidence } from '../../interfaces';
import { LocalExecutorService } from '../../execution';

interface NiktoJsonItem {
  id: string;
  OSVDB?: string;
  method?: string;
  url: string;
  msg: string;
  namelink?: string;
  iplink?: string;
  references?: string;
}

interface NiktoJsonOutput {
  host: string;
  ip: string;
  port: string;
  banner?: string;
  vulnerabilities: NiktoJsonItem[];
}

@Injectable()
export class NiktoScanner implements IScanner {
  readonly name = 'nikto';
  readonly version = '2.x';
  readonly supportedLanguages = ['web'];
  readonly outputFormat = 'json' as const;

  private readonly logger = new Logger(NiktoScanner.name);
  private readonly niktoPath: string;

  constructor(
    private readonly executor: LocalExecutorService,
    private readonly configService: ConfigService,
  ) {
    // Default to local nikto installation
    this.niktoPath = this.configService.get('NIKTO_PATH', 'C:/dev/nikto/program/nikto.pl');
  }

  async isAvailable(): Promise<boolean> {
    try {
      await fs.access(this.niktoPath);
      return true;
    } catch {
      return false;
    }
  }

  async getVersion(): Promise<string> {
    return '2.5.0'; // Nikto version from git
  }

  async scan(context: ScanContext): Promise<ScanOutput> {
    const outputFile = path.join(context.workDir, 'nikto-results.json');

    // Get target URLs from config
    const targetUrls = context.config?.targetUrls as string[] || [];
    if (targetUrls.length === 0) {
      this.logger.warn('No target URLs configured for Nikto scan');
      return {
        scanner: this.name,
        exitCode: 0,
        stdout: 'No target URLs configured',
        stderr: '',
        duration: 0,
        timedOut: false,
      };
    }

    // Nikto processes one host at a time, we'll scan the first one
    // In production, you might want to run multiple scans
    let targetUrl = targetUrls[0];
    let host: string;
    let port = '80';
    let ssl = false;

    // Ensure URL has a protocol for parsing
    if (!targetUrl.startsWith('http://') && !targetUrl.startsWith('https://')) {
      targetUrl = 'http://' + targetUrl;
    }

    try {
      const parsed = new URL(targetUrl);
      host = parsed.hostname;
      port = parsed.port || (parsed.protocol === 'https:' ? '443' : '80');
      ssl = parsed.protocol === 'https:';
    } catch {
      // Fallback: try to parse host:port format
      const parts = targetUrls[0].split(':');
      host = parts[0];
      if (parts[1]) {
        port = parts[1];
      }
    }

    if (!host) {
      this.logger.error('Failed to parse target URL for Nikto');
      return {
        scanner: this.name,
        exitCode: 1,
        stdout: '',
        stderr: 'Failed to parse target URL',
        duration: 0,
        timedOut: false,
      };
    }

    this.logger.log(`Nikto scanning host: ${host}:${port} (SSL: ${ssl})`);

    const args = [
      '-h', host,
      '-p', port,
      '-o', outputFile,
      '-Format', 'json',
      '-Tuning', '123457890abc', // All tuning options
      '-timeout', '10',
      '-maxtime', String(Math.floor(context.timeout / 1000 / 60)) + 'm',
      '-nointeractive',
    ];

    if (ssl) {
      args.push('-ssl');
    }

    // Add custom user agent if configured
    const userAgent = this.configService.get('NIKTO_USER_AGENT', '');
    if (userAgent) {
      args.push('-useragent', userAgent);
    }

    const result = await this.executor.execute({
      command: 'perl',
      args: [this.niktoPath, ...args],
      cwd: context.workDir,
      timeout: context.timeout,
    });

    // Check if output file was created
    try {
      await fs.access(outputFile);
      result.outputFile = outputFile;
    } catch {
      this.logger.warn('Nikto output file not created');
    }

    return result;
  }

  async parseOutput(output: ScanOutput): Promise<NormalizedFinding[]> {
    if (!output.outputFile) {
      this.logger.warn('No output file to parse');
      return [];
    }

    try {
      const content = await fs.readFile(output.outputFile, 'utf-8');

      // Nikto JSON can be in different formats depending on version
      // Try to parse as array or single object
      let results: NiktoJsonOutput[];
      try {
        const parsed = JSON.parse(content);
        results = Array.isArray(parsed) ? parsed : [parsed];
      } catch {
        // Try parsing as JSON lines
        results = content.trim().split('\n')
          .filter(Boolean)
          .map(line => JSON.parse(line));
      }

      const findings: NormalizedFinding[] = [];

      for (const result of results) {
        const host = `${result.host}:${result.port}`;

        for (const vuln of result.vulnerabilities || []) {
          const finding = this.convertVulnerability(vuln, host);
          if (finding) {
            findings.push(finding);
          }
        }
      }

      this.logger.log(`Parsed ${findings.length} Nikto findings`);
      return findings;
    } catch (error) {
      this.logger.error(`Failed to parse Nikto output: ${error}`);
      return [];
    }
  }

  private convertVulnerability(vuln: NiktoJsonItem, host: string): NormalizedFinding | null {
    const severity = this.determineSeverity(vuln);
    const fingerprint = this.generateFingerprint(vuln.id, host, vuln.url);

    // Extract CWE/CVE from OSVDB or message
    const cweIds = this.extractCweIds(vuln.msg);
    const cveIds = this.extractCveIds(vuln.msg);

    return {
      scanner: this.name,
      ruleId: `nikto-${vuln.id}`,
      severity,
      confidence: 'medium' as Confidence,
      title: this.cleanTitle(vuln.msg),
      description: this.buildDescription(vuln, host),
      filePath: `${host}${vuln.url}`,
      startLine: 0,
      cweIds,
      cveIds,
      owaspIds: this.determineOwaspIds(vuln.msg),
      references: this.extractReferences(vuln),
      fix: {
        description: this.suggestFix(vuln),
      },
      fingerprint,
      metadata: {
        niktoId: vuln.id,
        osvdbId: vuln.OSVDB,
        method: vuln.method,
        url: vuln.url,
        host,
      },
    };
  }

  private determineSeverity(vuln: NiktoJsonItem): Severity {
    const msg = vuln.msg.toLowerCase();

    // Critical issues
    if (msg.includes('remote code execution') ||
        msg.includes('sql injection') ||
        msg.includes('command injection') ||
        msg.includes('rce')) {
      return 'critical';
    }

    // High issues
    if (msg.includes('directory traversal') ||
        msg.includes('file inclusion') ||
        msg.includes('password') ||
        msg.includes('credentials') ||
        msg.includes('authentication bypass') ||
        msg.includes('admin') ||
        msg.includes('backdoor')) {
      return 'high';
    }

    // Medium issues
    if (msg.includes('xss') ||
        msg.includes('cross-site') ||
        msg.includes('csrf') ||
        msg.includes('session') ||
        msg.includes('disclosure') ||
        msg.includes('sensitive')) {
      return 'medium';
    }

    // Low issues
    if (msg.includes('outdated') ||
        msg.includes('version') ||
        msg.includes('header') ||
        msg.includes('banner')) {
      return 'low';
    }

    return 'info';
  }

  private cleanTitle(msg: string): string {
    // Truncate and clean up the message for use as a title
    let title = msg.replace(/^[:\s]+/, '').trim();
    if (title.length > 100) {
      title = title.substring(0, 97) + '...';
    }
    return title;
  }

  private buildDescription(vuln: NiktoJsonItem, host: string): string {
    let desc = `Nikto detected a potential vulnerability on ${host}.\n\n`;
    desc += `**Finding:** ${vuln.msg}\n`;
    desc += `**URL:** ${vuln.url}\n`;

    if (vuln.method) {
      desc += `**HTTP Method:** ${vuln.method}\n`;
    }

    if (vuln.OSVDB) {
      desc += `**OSVDB ID:** ${vuln.OSVDB}\n`;
    }

    return desc;
  }

  private extractCweIds(msg: string): string[] {
    const cwePattern = /CWE-(\d+)/gi;
    const matches = msg.match(cwePattern);
    return matches ? [...new Set(matches.map(m => m.toUpperCase()))] : [];
  }

  private extractCveIds(msg: string): string[] {
    const cvePattern = /CVE-\d{4}-\d+/gi;
    const matches = msg.match(cvePattern);
    return matches ? [...new Set(matches.map(m => m.toUpperCase()))] : [];
  }

  private determineOwaspIds(msg: string): string[] {
    const owaspIds: string[] = [];
    const msgLower = msg.toLowerCase();

    if (msgLower.includes('injection') || msgLower.includes('sql')) {
      owaspIds.push('A03:2021');
    }
    if (msgLower.includes('xss') || msgLower.includes('cross-site scripting')) {
      owaspIds.push('A03:2021');
    }
    if (msgLower.includes('authentication') || msgLower.includes('password')) {
      owaspIds.push('A07:2021');
    }
    if (msgLower.includes('disclosure') || msgLower.includes('sensitive')) {
      owaspIds.push('A01:2021');
    }
    if (msgLower.includes('misconfiguration') || msgLower.includes('default')) {
      owaspIds.push('A05:2021');
    }

    return owaspIds;
  }

  private extractReferences(vuln: NiktoJsonItem): string[] {
    const refs: string[] = [];

    if (vuln.OSVDB) {
      refs.push(`https://osvdb.org/show/osvdb/${vuln.OSVDB}`);
    }

    if (vuln.namelink) {
      refs.push(vuln.namelink);
    }

    if (vuln.references) {
      // Parse any URLs from references string
      const urlPattern = /https?:\/\/[^\s<>"]+/g;
      const matches = vuln.references.match(urlPattern);
      if (matches) {
        refs.push(...matches);
      }
    }

    return refs;
  }

  private suggestFix(vuln: NiktoJsonItem): string {
    const msgLower = vuln.msg.toLowerCase();
    const url = vuln.url.toLowerCase();

    // Critical injection vulnerabilities
    if (msgLower.includes('sql injection') || msgLower.includes('sqli')) {
      return 'Use parameterized queries or prepared statements. Never concatenate user input into SQL queries. Apply input validation and use ORM frameworks.';
    }

    if (msgLower.includes('command injection') || msgLower.includes('rce') || msgLower.includes('remote code')) {
      return 'Never pass user input directly to shell commands. Use safe APIs that avoid shell interpretation. Apply strict input validation with allowlists.';
    }

    if (msgLower.includes('xss') || msgLower.includes('cross-site scripting')) {
      return 'Encode all user input before rendering in HTML. Use Content-Security-Policy headers. Apply context-aware output encoding (HTML, JS, URL, CSS).';
    }

    if (msgLower.includes('file inclusion') || msgLower.includes('lfi') || msgLower.includes('rfi')) {
      return 'Never use user input in file paths. Use allowlists for permitted files. Disable remote file inclusion in PHP (allow_url_include=0).';
    }

    if (msgLower.includes('directory traversal') || msgLower.includes('path traversal')) {
      return 'Validate and sanitize file paths. Use basename() to strip directory components. Apply chroot or jail the web server process.';
    }

    // Authentication & Session
    if (msgLower.includes('authentication bypass')) {
      return 'Review authentication logic for flaws. Implement proper session management. Use secure authentication frameworks and multi-factor authentication.';
    }

    if (msgLower.includes('session') || msgLower.includes('cookie')) {
      return 'Set HttpOnly, Secure, and SameSite flags on cookies. Use strong session IDs. Implement session timeout and regeneration on login.';
    }

    if (msgLower.includes('password') || msgLower.includes('credential')) {
      return 'Change default credentials immediately. Enforce strong password policies. Store passwords using bcrypt/argon2 with proper salt.';
    }

    // Information disclosure
    if (msgLower.includes('directory listing')) {
      return 'Disable directory listing: Apache (Options -Indexes), Nginx (autoindex off), IIS (disable Directory Browsing feature).';
    }

    if (msgLower.includes('server signature') || msgLower.includes('server header') || msgLower.includes('x-powered-by')) {
      return 'Remove or obfuscate server headers: Apache (ServerTokens Prod, ServerSignature Off), Nginx (server_tokens off), remove X-Powered-By header.';
    }

    if (msgLower.includes('error') || msgLower.includes('stack trace') || msgLower.includes('debug')) {
      return 'Disable detailed error messages in production. Log errors server-side only. Show generic error pages to users.';
    }

    if (msgLower.includes('phpinfo') || msgLower.includes('info.php')) {
      return 'Remove phpinfo() pages from production. These expose sensitive server configuration including paths, modules, and environment variables.';
    }

    if (msgLower.includes('robots.txt') || msgLower.includes('sitemap')) {
      return 'Review robots.txt for sensitive path disclosure. Ensure it doesn\'t reveal admin paths or internal endpoints.';
    }

    // Common files & directories
    if (msgLower.includes('.git') || url.includes('.git')) {
      return 'Remove .git directory from web root or block access via server config. This exposes source code and commit history.';
    }

    if (msgLower.includes('.svn') || url.includes('.svn')) {
      return 'Remove .svn directory from web root or block access. This exposes source code and repository metadata.';
    }

    if (msgLower.includes('.env') || url.includes('.env')) {
      return 'Remove .env files from web root. Block access to dotfiles in server config. Move secrets to environment variables or secure vault.';
    }

    if (msgLower.includes('backup') || msgLower.includes('.bak') || msgLower.includes('.old') || msgLower.includes('.swp')) {
      return 'Remove backup and temporary files from web directories. Block access to common backup extensions (.bak, .old, .swp, ~) in server config.';
    }

    if (msgLower.includes('config') || msgLower.includes('web.config') || msgLower.includes('.htaccess')) {
      return 'Ensure config files are not web-accessible. Move sensitive config outside web root. Set proper file permissions.';
    }

    // Default/sample content
    if (msgLower.includes('default') || msgLower.includes('sample') || msgLower.includes('example')) {
      return 'Remove default installation files and sample content. These often contain known vulnerabilities or expose server information.';
    }

    if (msgLower.includes('admin') || msgLower.includes('manager') || msgLower.includes('console')) {
      return 'Restrict admin interface access by IP. Move to non-standard path. Require VPN or strong authentication. Remove if unused.';
    }

    // Headers
    if (msgLower.includes('x-frame-options') || msgLower.includes('clickjacking')) {
      return 'Add X-Frame-Options: DENY or SAMEORIGIN header to prevent clickjacking. Use Content-Security-Policy frame-ancestors for more control.';
    }

    if (msgLower.includes('content-type') || msgLower.includes('mime')) {
      return 'Add X-Content-Type-Options: nosniff header to prevent MIME-type sniffing attacks.';
    }

    if (msgLower.includes('hsts') || msgLower.includes('strict-transport')) {
      return 'Enable HSTS: Strict-Transport-Security: max-age=31536000; includeSubDomains. Ensure HTTPS is properly configured first.';
    }

    if (msgLower.includes('header')) {
      return 'Review and configure security headers: X-Frame-Options, X-Content-Type-Options, X-XSS-Protection, Content-Security-Policy, Strict-Transport-Security.';
    }

    // SSL/TLS
    if (msgLower.includes('ssl') || msgLower.includes('tls') || msgLower.includes('certificate')) {
      return 'Update TLS configuration: disable SSLv3/TLS 1.0/1.1, use TLS 1.2+. Enable perfect forward secrecy. Use strong cipher suites.';
    }

    // Versions
    if (msgLower.includes('outdated') || msgLower.includes('version') || msgLower.includes('vulnerable version')) {
      return 'Update to the latest patched version of the affected software. Subscribe to security advisories for timely updates.';
    }

    // Generic fallback with context
    const fixes: string[] = [];
    if (vuln.OSVDB) {
      fixes.push(`Check OSVDB-${vuln.OSVDB} for specific remediation steps.`);
    }
    if (vuln.url && vuln.url !== '/') {
      fixes.push(`Review the resource at ${vuln.url} and restrict access or remove if unnecessary.`);
    }
    fixes.push('Consult the scanner references for detailed remediation guidance.');

    return fixes.join(' ');
  }

  private generateFingerprint(id: string, host: string, url: string): string {
    const data = `${id}:${host}:${url}`;
    let hash = 0;
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return `nikto-${Math.abs(hash).toString(16)}`;
  }
}
