import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { IScanner, ScanContext, ScanOutput, NormalizedFinding, Severity, Confidence } from '../../interfaces';
import { LocalExecutorService } from '../../execution';

export type ScanPhase = 'discovery' | 'deep' | 'single';

// Nikto Tuning options mapping
// 0 = File Upload
// 1 = Interesting File / Seen in logs
// 2 = Misconfiguration / Default File
// 3 = Information Disclosure
// 4 = Injection (XSS/Script/HTML)
// 5 = Remote File Retrieval - Inside Web Root
// 6 = Denial of Service
// 7 = Remote File Retrieval - Server Wide
// 8 = Command Execution / Remote Shell
// 9 = SQL Injection
// a = Authentication Bypass
// b = Software Identification
// c = Remote Source Inclusion

// Technology to Tuning mapping for deep phase
const TECH_TUNING_MAP: Record<string, string> = {
  apache: '1b',   // Interesting files + Software ID
  nginx: '1b',
  iis: '1b',
  php: '5',       // Remote file retrieval
  cgi: '2',       // CGI misconfigurations
  tomcat: '1b8',  // Files, ID, Command exec
  wordpress: '1459', // Files, Injection, XSS, SQL
  joomla: '1459',
  drupal: '1459',
  default: '0',   // Default scan
};

interface NiktoJsonItem {
  id: string;
  OSVDB?: string;
  method?: string;
  url: string;
  msg: string;
  namelink?: string;
  iplink?: string;
  references?: string;
}

interface NiktoJsonOutput {
  host: string;
  ip: string;
  port: string;
  banner?: string;
  vulnerabilities: NiktoJsonItem[];
}

@Injectable()
export class NiktoScanner implements IScanner {
  readonly name = 'nikto';
  readonly version = '2.x';
  readonly supportedLanguages = ['web'];
  readonly outputFormat = 'json' as const;

  private readonly logger = new Logger(NiktoScanner.name);
  private readonly dockerImage: string;

  constructor(
    private readonly executor: LocalExecutorService,
    private readonly configService: ConfigService,
  ) {
    // Use Docker image for nikto
    this.dockerImage = this.configService.get('NIKTO_DOCKER_IMAGE', 'secfigo/nikto');
  }

  async isAvailable(): Promise<boolean> {
    // Check if docker is available
    const result = await this.executor.isCommandAvailable('docker');
    if (!result) {
      this.logger.warn('Docker is not available');
      return false;
    }

    // Verify the nikto image exists
    try {
      const checkResult = await this.executor.execute({
        command: 'docker',
        args: ['image', 'inspect', this.dockerImage],
        cwd: process.cwd(),
        timeout: 10000,
      });
      return checkResult.exitCode === 0;
    } catch {
      this.logger.warn(`Nikto Docker image ${this.dockerImage} not found`);
      return false;
    }
  }

  async getVersion(): Promise<string> {
    try {
      const result = await this.executor.execute({
        command: 'docker',
        args: ['run', '--rm', this.dockerImage, '-Version'],
        cwd: process.cwd(),
        timeout: 30000,
      });
      // Parse version from output
      const match = result.stdout.match(/Nikto main\s+(\d+\.\d+\.\d+)/);
      return match ? match[1] : '2.1.5';
    } catch {
      return '2.1.5';
    }
  }

  /**
   * Get tuning options based on scan phase and detected technologies
   */
  getTuningForPhase(phase: ScanPhase, techs: string[]): string {
    if (phase === 'discovery') {
      // Discovery: default quick scan (0 = default checks)
      return '0';
    }

    if (phase === 'deep' && techs.length > 0) {
      // Deep: combine tuning for all detected technologies
      const tuningSet = new Set<string>();

      for (const tech of techs) {
        const techLower = tech.toLowerCase();
        const tuning = TECH_TUNING_MAP[techLower];
        if (tuning) {
          for (const char of tuning) {
            tuningSet.add(char);
          }
        }
      }

      if (tuningSet.size > 0) {
        return Array.from(tuningSet).sort().join('');
      }
    }

    // Single/default: all tuning options
    return '123457890abc';
  }

  /**
   * Get tuning string for specific technologies
   */
  getTuningForTechs(techs: string[]): string {
    return this.getTuningForPhase('deep', techs);
  }

  async scan(context: ScanContext): Promise<ScanOutput> {
    // Get target URLs from config
    const targetUrls = context.config?.targetUrls as string[] || [];
    if (targetUrls.length === 0) {
      this.logger.warn('No target URLs configured for Nikto scan');
      return {
        scanner: this.name,
        exitCode: 0,
        stdout: 'No target URLs configured',
        stderr: '',
        duration: 0,
        timedOut: false,
      };
    }

    // Nikto processes one host at a time, we'll scan the first one
    let targetUrl = targetUrls[0];
    let host: string;
    let port = '80';
    let ssl = false;

    // Replace localhost with host.docker.internal for Docker networking
    targetUrl = targetUrl.replace(/localhost/gi, 'host.docker.internal');

    // Ensure URL has a protocol for parsing
    if (!targetUrl.startsWith('http://') && !targetUrl.startsWith('https://')) {
      targetUrl = 'http://' + targetUrl;
    }

    try {
      const parsed = new URL(targetUrl);
      host = parsed.hostname;
      port = parsed.port || (parsed.protocol === 'https:' ? '443' : '80');
      ssl = parsed.protocol === 'https:';
    } catch {
      // Fallback: try to parse host:port format
      const parts = targetUrls[0].replace(/localhost/gi, 'host.docker.internal').split(':');
      host = parts[0];
      if (parts[1]) {
        port = parts[1];
      }
    }

    if (!host) {
      this.logger.error('Failed to parse target URL for Nikto');
      return {
        scanner: this.name,
        exitCode: 1,
        stdout: '',
        stderr: 'Failed to parse target URL',
        duration: 0,
        timedOut: false,
      };
    }

    this.logger.log(`Nikto (Docker) scanning host: ${host}:${port} (SSL: ${ssl})`);

    // Get scan phase and detected technologies
    const scanPhase = (context.config?.scanPhase as ScanPhase) || 'single';
    const detectedTechs = (context.config?.detectedTechnologies as string[]) || [];

    // Determine tuning based on phase
    let tuning = this.getTuningForPhase(scanPhase, detectedTechs);
    this.logger.log(`Nikto scan phase: ${scanPhase}, tuning: ${tuning}`);

    // Build Docker run command
    // Output JSON to stdout for parsing
    const niktoArgs = [
      '-h', host,
      '-p', port,
      '-Format', 'json',
      '-o', '/dev/stdout',
      '-Tuning', tuning,
      '-timeout', '10',
      '-maxtime', String(Math.floor(context.timeout / 1000 / 60)) + 'm',
      '-nointeractive',
    ];

    if (ssl) {
      niktoArgs.push('-ssl');
    }

    // Add custom user agent if configured
    const userAgent = this.configService.get('NIKTO_USER_AGENT', '');
    if (userAgent) {
      niktoArgs.push('-useragent', userAgent);
    }

    const dockerArgs = [
      'run',
      '--rm',
      '--add-host=host.docker.internal:host-gateway', // Allow access to host machine
      this.dockerImage,
      ...niktoArgs,
    ];

    this.logger.log(`Running: docker ${dockerArgs.join(' ')}`);

    const result = await this.executor.execute({
      command: 'docker',
      args: dockerArgs,
      cwd: context.workDir,
      timeout: context.timeout,
    });

    // Handle Docker-specific errors
    if (result.stderr.includes('Cannot connect to the Docker daemon')) {
      this.logger.error('Docker daemon is not running');
      result.stderr = 'Docker daemon is not running. Please start Docker.';
    } else if (result.stderr.includes('image not found') || result.stderr.includes('No such image')) {
      this.logger.error(`Nikto Docker image not found: ${this.dockerImage}`);
      result.stderr = `Docker image ${this.dockerImage} not found. Run: docker pull ${this.dockerImage}`;
    } else if (result.stderr.includes('network') && result.stderr.includes('not found')) {
      this.logger.error('Docker network error');
      result.stderr = 'Docker network error. Check Docker networking configuration.';
    }

    // Store raw stdout for parsing (JSON output goes to stdout)
    result.rawOutput = result.stdout;

    return result;
  }

  async parseOutput(output: ScanOutput): Promise<NormalizedFinding[]> {
    // Get content from rawOutput (stdout) or fallback to stdout
    const content = output.rawOutput || output.stdout;

    if (!content || content.trim() === '' || content === 'No target URLs configured') {
      this.logger.warn('No Nikto output to parse');
      return [];
    }

    try {
      // Extract JSON from the output (nikto may include non-JSON text)
      let jsonContent = content;

      // Try to find JSON array or object in the output
      const jsonStart = content.indexOf('[');
      const jsonObjStart = content.indexOf('{');

      if (jsonStart >= 0 && (jsonObjStart < 0 || jsonStart < jsonObjStart)) {
        // Array format
        const jsonEnd = content.lastIndexOf(']');
        if (jsonEnd > jsonStart) {
          jsonContent = content.substring(jsonStart, jsonEnd + 1);
        }
      } else if (jsonObjStart >= 0) {
        // Object format
        const jsonEnd = content.lastIndexOf('}');
        if (jsonEnd > jsonObjStart) {
          jsonContent = content.substring(jsonObjStart, jsonEnd + 1);
        }
      }

      // Nikto JSON can be in different formats depending on version
      // Try to parse as array or single object
      let results: NiktoJsonOutput[];
      try {
        const parsed = JSON.parse(jsonContent);
        results = Array.isArray(parsed) ? parsed : [parsed];
      } catch {
        // Try parsing as JSON lines
        results = jsonContent.trim().split('\n')
          .filter((line: string) => line.trim().startsWith('{') || line.trim().startsWith('['))
          .map((line: string) => JSON.parse(line));
      }

      const findings: NormalizedFinding[] = [];

      for (const result of results) {
        const host = `${result.host}:${result.port}`;

        for (const vuln of result.vulnerabilities || []) {
          const finding = this.convertVulnerability(vuln, host);
          if (finding) {
            findings.push(finding);
          }
        }
      }

      this.logger.log(`Parsed ${findings.length} Nikto findings`);
      return findings;
    } catch (error) {
      this.logger.error(`Failed to parse Nikto output: ${error}`);
      this.logger.debug(`Raw output: ${content.substring(0, 500)}...`);
      return [];
    }
  }

  private convertVulnerability(vuln: NiktoJsonItem, host: string): NormalizedFinding | null {
    const severity = this.determineSeverity(vuln);
    const fingerprint = this.generateFingerprint(vuln.id, host, vuln.url);

    // Extract CWE/CVE from OSVDB or message
    const cweIds = this.extractCweIds(vuln.msg);
    const cveIds = this.extractCveIds(vuln.msg);

    return {
      scanner: this.name,
      ruleId: `nikto-${vuln.id}`,
      severity,
      confidence: 'medium' as Confidence,
      title: this.cleanTitle(vuln.msg),
      description: this.buildDescription(vuln, host),
      filePath: `${host}${vuln.url}`,
      startLine: 0,
      cweIds,
      cveIds,
      owaspIds: this.determineOwaspIds(vuln.msg),
      references: this.extractReferences(vuln),
      fix: {
        description: this.suggestFix(vuln),
      },
      fingerprint,
      metadata: {
        niktoId: vuln.id,
        osvdbId: vuln.OSVDB,
        method: vuln.method,
        url: vuln.url,
        host,
      },
    };
  }

  private determineSeverity(vuln: NiktoJsonItem): Severity {
    const msg = vuln.msg.toLowerCase();

    // Critical issues
    if (msg.includes('remote code execution') ||
        msg.includes('sql injection') ||
        msg.includes('command injection') ||
        msg.includes('rce')) {
      return 'critical';
    }

    // High issues
    if (msg.includes('directory traversal') ||
        msg.includes('file inclusion') ||
        msg.includes('password') ||
        msg.includes('credentials') ||
        msg.includes('authentication bypass') ||
        msg.includes('admin') ||
        msg.includes('backdoor')) {
      return 'high';
    }

    // Medium issues
    if (msg.includes('xss') ||
        msg.includes('cross-site') ||
        msg.includes('csrf') ||
        msg.includes('session') ||
        msg.includes('disclosure') ||
        msg.includes('sensitive')) {
      return 'medium';
    }

    // Low issues
    if (msg.includes('outdated') ||
        msg.includes('version') ||
        msg.includes('header') ||
        msg.includes('banner')) {
      return 'low';
    }

    return 'info';
  }

  private cleanTitle(msg: string): string {
    // Truncate and clean up the message for use as a title
    let title = msg.replace(/^[:\s]+/, '').trim();
    if (title.length > 100) {
      title = title.substring(0, 97) + '...';
    }
    return title;
  }

  private buildDescription(vuln: NiktoJsonItem, host: string): string {
    let desc = `Nikto detected a potential vulnerability on ${host}.\n\n`;
    desc += `**Finding:** ${vuln.msg}\n`;
    desc += `**URL:** ${vuln.url}\n`;

    if (vuln.method) {
      desc += `**HTTP Method:** ${vuln.method}\n`;
    }

    if (vuln.OSVDB) {
      desc += `**OSVDB ID:** ${vuln.OSVDB}\n`;
    }

    return desc;
  }

  private extractCweIds(msg: string): string[] {
    const cwePattern = /CWE-(\d+)/gi;
    const matches = msg.match(cwePattern);
    return matches ? [...new Set(matches.map(m => m.toUpperCase()))] : [];
  }

  private extractCveIds(msg: string): string[] {
    const cvePattern = /CVE-\d{4}-\d+/gi;
    const matches = msg.match(cvePattern);
    return matches ? [...new Set(matches.map(m => m.toUpperCase()))] : [];
  }

  private determineOwaspIds(msg: string): string[] {
    const owaspIds: string[] = [];
    const msgLower = msg.toLowerCase();

    if (msgLower.includes('injection') || msgLower.includes('sql')) {
      owaspIds.push('A03:2021');
    }
    if (msgLower.includes('xss') || msgLower.includes('cross-site scripting')) {
      owaspIds.push('A03:2021');
    }
    if (msgLower.includes('authentication') || msgLower.includes('password')) {
      owaspIds.push('A07:2021');
    }
    if (msgLower.includes('disclosure') || msgLower.includes('sensitive')) {
      owaspIds.push('A01:2021');
    }
    if (msgLower.includes('misconfiguration') || msgLower.includes('default')) {
      owaspIds.push('A05:2021');
    }

    return owaspIds;
  }

  private extractReferences(vuln: NiktoJsonItem): string[] {
    const refs: string[] = [];

    if (vuln.OSVDB) {
      refs.push(`https://osvdb.org/show/osvdb/${vuln.OSVDB}`);
    }

    if (vuln.namelink) {
      refs.push(vuln.namelink);
    }

    if (vuln.references) {
      // Parse any URLs from references string
      const urlPattern = /https?:\/\/[^\s<>"]+/g;
      const matches = vuln.references.match(urlPattern);
      if (matches) {
        refs.push(...matches);
      }
    }

    return refs;
  }

  private suggestFix(vuln: NiktoJsonItem): string {
    const msgLower = vuln.msg.toLowerCase();
    const url = vuln.url.toLowerCase();

    // Critical injection vulnerabilities
    if (msgLower.includes('sql injection') || msgLower.includes('sqli')) {
      return 'Use parameterized queries or prepared statements. Never concatenate user input into SQL queries. Apply input validation and use ORM frameworks.';
    }

    if (msgLower.includes('command injection') || msgLower.includes('rce') || msgLower.includes('remote code')) {
      return 'Never pass user input directly to shell commands. Use safe APIs that avoid shell interpretation. Apply strict input validation with allowlists.';
    }

    if (msgLower.includes('xss') || msgLower.includes('cross-site scripting')) {
      return 'Encode all user input before rendering in HTML. Use Content-Security-Policy headers. Apply context-aware output encoding (HTML, JS, URL, CSS).';
    }

    if (msgLower.includes('file inclusion') || msgLower.includes('lfi') || msgLower.includes('rfi')) {
      return 'Never use user input in file paths. Use allowlists for permitted files. Disable remote file inclusion in PHP (allow_url_include=0).';
    }

    if (msgLower.includes('directory traversal') || msgLower.includes('path traversal')) {
      return 'Validate and sanitize file paths. Use basename() to strip directory components. Apply chroot or jail the web server process.';
    }

    // Authentication & Session
    if (msgLower.includes('authentication bypass')) {
      return 'Review authentication logic for flaws. Implement proper session management. Use secure authentication frameworks and multi-factor authentication.';
    }

    if (msgLower.includes('session') || msgLower.includes('cookie')) {
      return 'Set HttpOnly, Secure, and SameSite flags on cookies. Use strong session IDs. Implement session timeout and regeneration on login.';
    }

    if (msgLower.includes('password') || msgLower.includes('credential')) {
      return 'Change default credentials immediately. Enforce strong password policies. Store passwords using bcrypt/argon2 with proper salt.';
    }

    // Information disclosure
    if (msgLower.includes('directory listing')) {
      return 'Disable directory listing: Apache (Options -Indexes), Nginx (autoindex off), IIS (disable Directory Browsing feature).';
    }

    if (msgLower.includes('server signature') || msgLower.includes('server header') || msgLower.includes('x-powered-by')) {
      return 'Remove or obfuscate server headers: Apache (ServerTokens Prod, ServerSignature Off), Nginx (server_tokens off), remove X-Powered-By header.';
    }

    if (msgLower.includes('error') || msgLower.includes('stack trace') || msgLower.includes('debug')) {
      return 'Disable detailed error messages in production. Log errors server-side only. Show generic error pages to users.';
    }

    if (msgLower.includes('phpinfo') || msgLower.includes('info.php')) {
      return 'Remove phpinfo() pages from production. These expose sensitive server configuration including paths, modules, and environment variables.';
    }

    if (msgLower.includes('robots.txt') || msgLower.includes('sitemap')) {
      return 'Review robots.txt for sensitive path disclosure. Ensure it doesn\'t reveal admin paths or internal endpoints.';
    }

    // Common files & directories
    if (msgLower.includes('.git') || url.includes('.git')) {
      return 'Remove .git directory from web root or block access via server config. This exposes source code and commit history.';
    }

    if (msgLower.includes('.svn') || url.includes('.svn')) {
      return 'Remove .svn directory from web root or block access. This exposes source code and repository metadata.';
    }

    if (msgLower.includes('.env') || url.includes('.env')) {
      return 'Remove .env files from web root. Block access to dotfiles in server config. Move secrets to environment variables or secure vault.';
    }

    if (msgLower.includes('backup') || msgLower.includes('.bak') || msgLower.includes('.old') || msgLower.includes('.swp')) {
      return 'Remove backup and temporary files from web directories. Block access to common backup extensions (.bak, .old, .swp, ~) in server config.';
    }

    if (msgLower.includes('config') || msgLower.includes('web.config') || msgLower.includes('.htaccess')) {
      return 'Ensure config files are not web-accessible. Move sensitive config outside web root. Set proper file permissions.';
    }

    // Default/sample content
    if (msgLower.includes('default') || msgLower.includes('sample') || msgLower.includes('example')) {
      return 'Remove default installation files and sample content. These often contain known vulnerabilities or expose server information.';
    }

    if (msgLower.includes('admin') || msgLower.includes('manager') || msgLower.includes('console')) {
      return 'Restrict admin interface access by IP. Move to non-standard path. Require VPN or strong authentication. Remove if unused.';
    }

    // Headers
    if (msgLower.includes('x-frame-options') || msgLower.includes('clickjacking')) {
      return 'Add X-Frame-Options: DENY or SAMEORIGIN header to prevent clickjacking. Use Content-Security-Policy frame-ancestors for more control.';
    }

    if (msgLower.includes('content-type') || msgLower.includes('mime')) {
      return 'Add X-Content-Type-Options: nosniff header to prevent MIME-type sniffing attacks.';
    }

    if (msgLower.includes('hsts') || msgLower.includes('strict-transport')) {
      return 'Enable HSTS: Strict-Transport-Security: max-age=31536000; includeSubDomains. Ensure HTTPS is properly configured first.';
    }

    if (msgLower.includes('header')) {
      return 'Review and configure security headers: X-Frame-Options, X-Content-Type-Options, X-XSS-Protection, Content-Security-Policy, Strict-Transport-Security.';
    }

    // SSL/TLS
    if (msgLower.includes('ssl') || msgLower.includes('tls') || msgLower.includes('certificate')) {
      return 'Update TLS configuration: disable SSLv3/TLS 1.0/1.1, use TLS 1.2+. Enable perfect forward secrecy. Use strong cipher suites.';
    }

    // Versions
    if (msgLower.includes('outdated') || msgLower.includes('version') || msgLower.includes('vulnerable version')) {
      return 'Update to the latest patched version of the affected software. Subscribe to security advisories for timely updates.';
    }

    // Generic fallback with context
    const fixes: string[] = [];
    if (vuln.OSVDB) {
      fixes.push(`Check OSVDB-${vuln.OSVDB} for specific remediation steps.`);
    }
    if (vuln.url && vuln.url !== '/') {
      fixes.push(`Review the resource at ${vuln.url} and restrict access or remove if unnecessary.`);
    }
    fixes.push('Consult the scanner references for detailed remediation guidance.');

    return fixes.join(' ');
  }

  private generateFingerprint(id: string, host: string, url: string): string {
    const data = `${id}:${host}:${url}`;
    let hash = 0;
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return `nikto-${Math.abs(hash).toString(16)}`;
  }
}
