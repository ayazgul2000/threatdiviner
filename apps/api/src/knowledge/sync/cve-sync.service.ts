// apps/api/src/knowledge/sync/cve-sync.service.ts
// NVD CVE synchronization service

import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from '../../prisma/prisma.service';

const NVD_API_BASE = 'https://services.nvd.nist.gov/rest/json/cves/2.0';

interface NvdCve {
  id: string;
  descriptions: { lang: string; value: string }[];
  metrics?: {
    cvssMetricV31?: { cvssData: { baseScore: number; baseSeverity: string; vectorString: string } }[];
    cvssMetricV2?: { cvssData: { baseScore: number } }[];
  };
  weaknesses?: { description: { lang: string; value: string }[] }[];
  configurations?: any[];
  references?: { url: string; source: string }[];
  published: string;
  lastModified: string;
}

@Injectable()
export class CveSyncService {
  private readonly logger = new Logger(CveSyncService.name);
  private readonly apiKey = process.env.NVD_API_KEY;

  constructor(private readonly prisma: PrismaService) {}

  // Hourly delta sync
  @Cron(CronExpression.EVERY_HOUR)
  async syncDelta(): Promise<{ synced: number; errors: number }> {
    const lastModStart = new Date();
    lastModStart.setHours(lastModStart.getHours() - 2);
    return this.fetchAndSync(lastModStart);
  }

  // Daily full sync (last 7 days)
  @Cron('0 2 * * *') // 2 AM UTC
  async syncDaily(): Promise<{ synced: number; errors: number }> {
    const lastModStart = new Date();
    lastModStart.setDate(lastModStart.getDate() - 7);
    return this.fetchAndSync(lastModStart);
  }

  async fetchAndSync(since: Date): Promise<{ synced: number; errors: number }> {
    this.logger.log(`Starting CVE sync since ${since.toISOString()}`);
    let synced = 0, errors = 0, startIndex = 0;
    const resultsPerPage = 500;

    try {
      while (true) {
        const url = new URL(NVD_API_BASE);
        url.searchParams.set('lastModStartDate', since.toISOString());
        url.searchParams.set('lastModEndDate', new Date().toISOString());
        url.searchParams.set('startIndex', String(startIndex));
        url.searchParams.set('resultsPerPage', String(resultsPerPage));

        const headers: Record<string, string> = { 'Accept': 'application/json' };
        if (this.apiKey) headers['apiKey'] = this.apiKey;

        const res = await fetch(url.toString(), { headers });
        if (!res.ok) {
          this.logger.error(`NVD API error: ${res.status}`);
          break;
        }

        const data = await res.json();
        const vulnerabilities = data.vulnerabilities || [];
        
        if (vulnerabilities.length === 0) break;

        for (const item of vulnerabilities) {
          try {
            await this.upsertCve(item.cve);
            synced++;
          } catch (e) {
            errors++;
            this.logger.warn(`Failed to sync ${item.cve?.id}: ${e}`);
          }
        }

        if (vulnerabilities.length < resultsPerPage) break;
        startIndex += resultsPerPage;

        // Rate limit: 6 seconds between requests (NVD limit without API key)
        await new Promise(r => setTimeout(r, this.apiKey ? 600 : 6000));
      }

      this.logger.log(`CVE sync complete: ${synced} synced, ${errors} errors`);
    } catch (e) {
      this.logger.error('CVE sync failed', e);
    }

    return { synced, errors };
  }

  private async upsertCve(cve: NvdCve): Promise<void> {
    const cvss31 = cve.metrics?.cvssMetricV31?.[0]?.cvssData;
    const description = cve.descriptions?.find(d => d.lang === 'en')?.value || '';
    const cweIds = cve.weaknesses?.flatMap(w => w.description.map(d => d.value)).filter(v => v.startsWith('CWE-')) || [];

    await this.prisma.cve.upsert({
      where: { id: cve.id },
      update: {
        description,
        cvssV3Score: cvss31?.baseScore,
        cvssV3Severity: cvss31?.baseSeverity,
        cvssV3Vector: cvss31?.vectorString,
        cweIds,
        references: cve.references || [],
        affectedProducts: cve.configurations || [],
        lastModifiedDate: new Date(cve.lastModified),
      },
      create: {
        id: cve.id,
        description,
        cvssV3Score: cvss31?.baseScore,
        cvssV3Severity: cvss31?.baseSeverity,
        cvssV3Vector: cvss31?.vectorString,
        cweIds,
        references: cve.references || [],
        affectedProducts: cve.configurations || [],
        publishedDate: new Date(cve.published),
        lastModifiedDate: new Date(cve.lastModified),
      },
    });
  }

  // Manual sync trigger
  async syncRange(startDate: Date, _endDate: Date): Promise<{ synced: number; errors: number }> {
    return this.fetchAndSync(startDate);
  }

  // Alias for orchestrator
  async syncRecentCves(): Promise<{ synced: number; errors: number }> {
    return this.syncDelta();
  }
}
