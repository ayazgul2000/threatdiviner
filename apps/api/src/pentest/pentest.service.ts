import { Injectable, Logger, NotFoundException, BadRequestException, Inject } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { ConfigService } from '@nestjs/config';
import { RedisClientType } from 'redis';
import {
  CreateTargetDto,
  UpdateTargetDto,
  CreateScanDto,
  UpdateFindingStatusDto,
  TargetQueryDto,
  ScanQueryDto,
  FindingQueryDto,
  StartTargetScanDto,
} from './dto';
import { SqlmapScanner, SSLyzeScanner, NiktoScanner } from '../scanners/pentest';
import { NucleiScanner } from '../scanners/dast/nuclei';
import { ZapScanner } from '../scanners/dast/zap';
import { KatanaScanner } from '../scanners/discovery/katana/katana.scanner';
import { LocalExecutorService } from '../scanners/execution';
import { QueueService } from '../queue/services/queue.service';
import { REDIS_PUBSUB } from '../queue/queue.constants';
import * as path from 'path';
import * as fs from 'fs/promises';
import * as os from 'os';

@Injectable()
export class PenTestService {
  private readonly logger = new Logger(PenTestService.name);
  private readonly scanners: Map<string, any>;

  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ConfigService,
    private readonly executor: LocalExecutorService,
    private readonly queueService: QueueService,
    @Inject(REDIS_PUBSUB.SCAN_CANCELLATION) private readonly redisPublisher: RedisClientType,
  ) {
    // Initialize scanners
    this.scanners = new Map();
    this.scanners.set('sqlmap', new SqlmapScanner(this.executor, this.configService));
    this.scanners.set('sslyze', new SSLyzeScanner(this.executor, this.configService));
    this.scanners.set('nikto', new NiktoScanner(this.executor, this.configService));
    this.scanners.set('nuclei', new NucleiScanner(this.executor, this.configService));
    this.scanners.set('zap', new ZapScanner(this.executor, this.configService));
    this.scanners.set('katana', new KatanaScanner(this.executor, this.configService));
  }

  // ============ TARGETS ============

  async getTargets(tenantId: string, query: TargetQueryDto) {
    const where: any = { tenantId };

    if (query.projectId) {
      where.projectId = query.projectId;
    }
    if (query.type) {
      where.type = query.type;
    }
    if (query.isActive !== undefined) {
      where.isActive = query.isActive;
    }

    const targets = await this.prisma.penTestTarget.findMany({
      where,
      include: {
        scans: {
          take: 1,
          orderBy: { createdAt: 'desc' },
          select: {
            id: true,
            status: true,
            findingsCount: true,
            criticalCount: true,
            highCount: true,
            completedAt: true,
          },
        },
        _count: {
          select: { scans: true },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    return targets.map(target => ({
      ...target,
      lastScan: target.scans[0] || null,
      scanCount: target._count.scans,
      scans: undefined,
      _count: undefined,
    }));
  }

  async getTarget(tenantId: string, id: string) {
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id, tenantId },
      include: {
        scans: {
          orderBy: { createdAt: 'desc' },
          take: 10,
          include: {
            _count: {
              select: { findings: true },
            },
          },
        },
      },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    return target;
  }

  async createTarget(tenantId: string, dto: CreateTargetDto) {
    return this.prisma.penTestTarget.create({
      data: {
        tenantId,
        name: dto.name,
        url: dto.url,
        type: dto.type || 'web_application',
        description: dto.description,
        authType: dto.authType || 'none',
        authCredentials: dto.authCredentials ? JSON.parse(JSON.stringify(dto.authCredentials)) : undefined,
        authConfig: dto.authConfig ? JSON.parse(JSON.stringify(dto.authConfig)) : undefined,
        headers: dto.headers ? JSON.parse(JSON.stringify(dto.headers)) : {},
        defaultScanners: dto.defaultScanners || ['nuclei'],
        defaultScanMode: dto.defaultScanMode || 'standard',
        rateLimitPreset: dto.rateLimitPreset || 'medium',
        excludePaths: dto.excludePaths || [],
        projectId: dto.projectId,
      },
    });
  }

  async updateTarget(tenantId: string, id: string, dto: UpdateTargetDto) {
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id, tenantId },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    const updateData: any = {};

    // Copy simple fields
    if (dto.name !== undefined) updateData.name = dto.name;
    if (dto.url !== undefined) updateData.url = dto.url;
    if (dto.type !== undefined) updateData.type = dto.type;
    if (dto.description !== undefined) updateData.description = dto.description;
    if (dto.authType !== undefined) updateData.authType = dto.authType;
    if (dto.isActive !== undefined) updateData.isActive = dto.isActive;
    if (dto.defaultScanMode !== undefined) updateData.defaultScanMode = dto.defaultScanMode;
    if (dto.rateLimitPreset !== undefined) updateData.rateLimitPreset = dto.rateLimitPreset;
    if (dto.defaultScanners !== undefined) updateData.defaultScanners = dto.defaultScanners;
    if (dto.excludePaths !== undefined) updateData.excludePaths = dto.excludePaths;

    // Handle JSON fields
    if (dto.authCredentials) {
      updateData.authCredentials = JSON.parse(JSON.stringify(dto.authCredentials));
    }
    if (dto.authConfig) {
      updateData.authConfig = JSON.parse(JSON.stringify(dto.authConfig));
    }
    if (dto.headers) {
      updateData.headers = JSON.parse(JSON.stringify(dto.headers));
    }

    return this.prisma.penTestTarget.update({
      where: { id },
      data: updateData,
    });
  }

  async deleteTarget(tenantId: string, id: string) {
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id, tenantId },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    await this.prisma.penTestTarget.delete({ where: { id } });
    return { success: true };
  }

  /**
   * Start a scan for a specific target using its default settings
   * Now uses mode-based scanning: quick | standard | comprehensive
   */
  async startTargetScan(tenantId: string, targetId: string, dto: StartTargetScanDto) {
    // Verify target exists and belongs to tenant
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id: targetId, tenantId },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    // Use provided scan mode or target default
    const scanMode = dto.scanMode || target.defaultScanMode || 'standard';

    // Validate scan mode
    const validModes = ['quick', 'standard', 'comprehensive'];
    if (!validModes.includes(scanMode)) {
      throw new BadRequestException(`Invalid scan mode: ${scanMode}. Valid modes: ${validModes.join(', ')}`);
    }

    // Create scan record with target's auth config
    // Scanners are now determined by mode in the processor, not stored in DB
    const scan = await this.prisma.penTestScan.create({
      data: {
        tenantId,
        targetId,
        scanMode,
        scanPhase: 'discovery', // All modes start with discovery
        scanners: [], // Deprecated: scanners determined by mode
        config: {
          ...dto.config,
          authType: target.authType,
          authCredentials: target.authCredentials,
          headers: target.headers,
          rateLimitPreset: target.rateLimitPreset || 'medium',
          excludePaths: target.excludePaths,
        },
        status: 'queued',
      },
      include: {
        target: true,
      },
    });

    // Update target lastScanAt and lastScanId
    await this.prisma.penTestTarget.update({
      where: { id: targetId },
      data: {
        lastScanAt: new Date(),
        lastScanId: scan.id,
      },
    });

    // Enqueue the scan job with mode-based config
    await this.queueService.enqueueTargetScan({
      scanId: scan.id,
      tenantId,
      targetId,
      targetUrl: target.url,
      targetName: target.name,
      scanMode: scanMode as 'quick' | 'standard' | 'comprehensive',
      config: {
        authType: target.authType || undefined,
        authCredentials: target.authCredentials as Record<string, unknown> | undefined,
        headers: target.headers as Record<string, string> | undefined,
        rateLimitPreset: (target.rateLimitPreset as 'low' | 'medium' | 'high') || 'medium',
        excludePaths: target.excludePaths,
        timeout: scanMode === 'quick' ? 180000 : scanMode === 'standard' ? 300000 : 600000,
      },
    });

    this.logger.log(`${scanMode} target scan ${scan.id} queued for ${target.name}`);

    return scan;
  }

  /**
   * Get scans for a specific target
   */
  async getTargetScans(tenantId: string, targetId: string) {
    // Verify target exists
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id: targetId, tenantId },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    return this.prisma.penTestScan.findMany({
      where: { targetId, tenantId },
      include: {
        _count: {
          select: { findings: true },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  /**
   * Get a specific scan for a target
   */
  async getTargetScan(tenantId: string, targetId: string, scanId: string) {
    // Verify target exists
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id: targetId, tenantId },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    const scan = await this.prisma.penTestScan.findFirst({
      where: { id: scanId, targetId, tenantId },
      include: {
        target: true,
        findings: {
          orderBy: [
            { severity: 'asc' },
            { createdAt: 'desc' },
          ],
        },
      },
    });

    if (!scan) {
      throw new NotFoundException('Scan not found');
    }

    return scan;
  }

  // ============ SCANS ============

  async getScans(tenantId: string, query: ScanQueryDto) {
    const where: any = { tenantId };

    if (query.targetId) {
      where.targetId = query.targetId;
    }
    if (query.status) {
      where.status = query.status;
    }

    return this.prisma.penTestScan.findMany({
      where,
      include: {
        target: {
          select: {
            id: true,
            name: true,
            url: true,
            type: true,
          },
        },
        _count: {
          select: { findings: true },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async getScan(tenantId: string, id: string) {
    const scan = await this.prisma.penTestScan.findFirst({
      where: { id, tenantId },
      include: {
        target: true,
        findings: {
          orderBy: [
            { severity: 'asc' },
            { createdAt: 'desc' },
          ],
        },
      },
    });

    if (!scan) {
      throw new NotFoundException('Scan not found');
    }

    return scan;
  }

  async createScan(tenantId: string, dto: CreateScanDto) {
    // Verify target exists and belongs to tenant
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id: dto.targetId, tenantId },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    // Validate scanners
    const validScanners = ['katana', 'sqlmap', 'sslyze', 'nikto', 'zap', 'nuclei'];
    const invalidScanners = dto.scanners.filter(s => !validScanners.includes(s));
    if (invalidScanners.length > 0) {
      throw new BadRequestException(`Invalid scanners: ${invalidScanners.join(', ')}`);
    }

    // Create scan record
    const scan = await this.prisma.penTestScan.create({
      data: {
        tenantId,
        targetId: dto.targetId,
        scanners: dto.scanners,
        config: dto.config ? JSON.parse(JSON.stringify(dto.config)) : {},
        status: 'pending',
      },
      include: {
        target: true,
      },
    });

    // Start scan asynchronously
    this.executeScan(scan.id, tenantId).catch(err => {
      this.logger.error(`Scan ${scan.id} failed: ${err.message}`);
    });

    return scan;
  }

  async cancelScan(tenantId: string, id: string) {
    const scan = await this.prisma.penTestScan.findFirst({
      where: { id, tenantId },
    });

    if (!scan) {
      throw new NotFoundException('Scan not found');
    }

    if (scan.status === 'completed' || scan.status === 'failed') {
      throw new BadRequestException('Cannot cancel completed or failed scan');
    }

    // 1. Publish cancellation signal via Redis Pub/Sub
    // This immediately notifies all workers to kill the scan
    try {
      const subscriberCount = await this.redisPublisher.publish(REDIS_PUBSUB.SCAN_CANCELLATION, id);
      this.logger.log(`[CANCEL] Published to channel '${REDIS_PUBSUB.SCAN_CANCELLATION}' for scan ${id} - ${subscriberCount} subscriber(s) received`);
      if (subscriberCount === 0) {
        this.logger.warn(`[CANCEL] No subscribers received the cancellation signal! Worker may not be connected to Redis Pub/Sub`);
      }
    } catch (err) {
      this.logger.error(`[CANCEL] Failed to publish cancellation signal: ${err}`);
    }

    // 2. Kill any running scanner processes (redundant but ensures cleanup)
    const processKilled = this.executor.killProcess(id);
    this.logger.log(`Process kill result for scan ${id}: ${processKilled}`);

    // 3. Try to cancel the BullMQ job (for queued/waiting jobs)
    const jobCancelled = await this.queueService.cancelTargetScan(id);
    this.logger.log(`Job cancellation result for scan ${id}: ${jobCancelled}`);

    // 4. Update DB status
    await this.prisma.penTestScan.update({
      where: { id },
      data: {
        status: 'cancelled',
        completedAt: new Date(),
      },
    });

    return { success: true, processKilled, jobCancelled };
  }

  async retryFailedTemplates(tenantId: string, scanId: string, templateIds: string[]) {
    // Get the original scan
    const scan = await this.prisma.penTestScan.findFirst({
      where: { id: scanId, tenantId },
      include: {
        target: true,
      },
    });

    if (!scan) {
      throw new NotFoundException('Scan not found');
    }

    if (!scan.target) {
      throw new BadRequestException('Scan has no associated target');
    }

    if (!templateIds || templateIds.length === 0) {
      throw new BadRequestException('No template IDs provided');
    }

    this.logger.log(`Retrying ${templateIds.length} failed templates for scan ${scanId}`);

    // Get the nuclei scanner
    const nucleiScanner = this.scanners.get('nuclei') as NucleiScanner;
    if (!nucleiScanner) {
      throw new BadRequestException('Nuclei scanner not available');
    }

    // Create work directory
    const workDir = path.join(os.tmpdir(), `nuclei-retry-${scanId}-${Date.now()}`);
    await fs.mkdir(workDir, { recursive: true });

    try {
      // Build scan context
      const context = {
        scanId,
        workDir,
        targetPaths: [],
        excludePaths: [],
        languages: [],
        timeout: 300000, // 5 minutes for retry
        config: {
          targetUrls: [scan.target.url],
          rateLimitPreset: (scan.target as any).rateLimitPreset || 'medium',
        },
      };

      // Run retry scan
      const output = await nucleiScanner.retryFailedTemplates(context, templateIds);
      const findings = await nucleiScanner.parseOutput(output);

      // Store new findings
      const newFindings = [];
      for (const finding of findings) {
        const created = await this.prisma.penTestFinding.create({
          data: {
            scanId,
            tenantId,
            scanner: 'nuclei',
            ruleId: finding.ruleId,
            severity: finding.severity,
            confidence: finding.confidence || 'medium',
            title: finding.title,
            description: finding.description,
            url: finding.filePath || scan.target.url,
            cweIds: finding.cweIds || [],
            cveIds: finding.cveIds || [],
            owaspIds: finding.owaspIds || [],
            references: finding.references || [],
            remediation: finding.fix?.description,
            fingerprint: finding.fingerprint,
            metadata: { ...finding.metadata, phase: 'retry' },
          },
        });
        newFindings.push(created);
      }

      // Update scan findings count
      const existingCount = await this.prisma.penTestFinding.count({
        where: { scanId },
      });

      await this.prisma.penTestScan.update({
        where: { id: scanId },
        data: {
          findingsCount: existingCount,
        },
      });

      return {
        success: true,
        retriedTemplates: templateIds.length,
        newFindingsCount: newFindings.length,
        templateStats: output.templateStats,
      };
    } finally {
      // Cleanup
      try {
        await fs.rm(workDir, { recursive: true, force: true });
      } catch {
        // Ignore cleanup errors
      }
    }
  }

  // ============ FINDINGS ============

  async getFindings(tenantId: string, query: FindingQueryDto) {
    const where: any = { tenantId };

    if (query.scanId) {
      where.scanId = query.scanId;
    }
    if (query.targetId) {
      where.scan = { targetId: query.targetId };
    }
    if (query.severity) {
      where.severity = query.severity;
    }
    if (query.status) {
      where.status = query.status;
    }
    if (query.scanner) {
      where.scanner = query.scanner;
    }

    return this.prisma.penTestFinding.findMany({
      where,
      include: {
        scan: {
          select: {
            id: true,
            target: {
              select: {
                id: true,
                name: true,
                url: true,
              },
            },
          },
        },
      },
      orderBy: [
        { severity: 'asc' },
        { createdAt: 'desc' },
      ],
    });
  }

  async getFinding(tenantId: string, id: string) {
    const finding = await this.prisma.penTestFinding.findFirst({
      where: { id, tenantId },
      include: {
        scan: {
          include: {
            target: true,
          },
        },
      },
    });

    if (!finding) {
      throw new NotFoundException('Finding not found');
    }

    return finding;
  }

  async updateFindingStatus(tenantId: string, id: string, dto: UpdateFindingStatusDto, userId: string) {
    const finding = await this.prisma.penTestFinding.findFirst({
      where: { id, tenantId },
    });

    if (!finding) {
      throw new NotFoundException('Finding not found');
    }

    const updatedMetadata = {
      ...(typeof finding.metadata === 'object' && finding.metadata !== null ? finding.metadata : {}),
      notes: dto.notes,
    };

    return this.prisma.penTestFinding.update({
      where: { id },
      data: {
        status: dto.status,
        verifiedAt: new Date(),
        verifiedBy: userId,
        metadata: updatedMetadata,
      },
    });
  }

  // ============ SCANNER AVAILABILITY ============

  async getScannerStatus() {
    const status: Record<string, { available: boolean; version: string | null }> = {};

    for (const [name, scanner] of this.scanners) {
      try {
        const available = await scanner.isAvailable();
        let version: string | null = null;
        if (available) {
          try {
            version = await scanner.getVersion();
          } catch {
            // Version check may fail even if available
          }
        }
        status[name] = { available, version };
      } catch {
        status[name] = { available: false, version: null };
      }
    }

    return status;
  }

  // ============ SCAN EXECUTION ============

  private async executeScan(scanId: string, tenantId: string) {
    const scan = await this.prisma.penTestScan.findFirst({
      where: { id: scanId, tenantId },
      include: { target: true },
    });

    if (!scan) {
      throw new Error('Scan not found');
    }

    // Update status to running
    await this.prisma.penTestScan.update({
      where: { id: scanId },
      data: {
        status: 'running',
        startedAt: new Date(),
      },
    });

    // Update target lastScanAt
    await this.prisma.penTestTarget.update({
      where: { id: scan.targetId },
      data: { lastScanAt: new Date() },
    });

    const startTime = Date.now();
    const allFindings: any[] = [];
    const severityCounts = { critical: 0, high: 0, medium: 0, low: 0, info: 0 };

    try {
      // Create temp work directory
      const workDir = path.join(os.tmpdir(), `pentest-${scanId}`);
      await fs.mkdir(workDir, { recursive: true });

      // Run each selected scanner
      for (const scannerName of scan.scanners) {
        const scanner = this.scanners.get(scannerName);
        if (!scanner) {
          this.logger.warn(`Scanner ${scannerName} not found, skipping`);
          continue;
        }

        try {
          const isAvailable = await scanner.isAvailable();
          if (!isAvailable) {
            this.logger.warn(`Scanner ${scannerName} not available, skipping`);
            continue;
          }

          this.logger.log(`Running ${scannerName} against ${scan.target.url}`);

          // Prepare scan context
          const context = {
            workDir,
            timeout: 300000, // 5 minutes per scanner
            config: {
              targetUrls: [scan.target.url],
              ...(scan.config as object || {}),
            },
          };

          // Run scan
          const output = await scanner.scan(context);

          // Parse results
          const findings = await scanner.parseOutput(output);

          // Add findings to database
          for (const finding of findings) {
            const created = await this.prisma.penTestFinding.create({
              data: {
                scanId,
                tenantId,
                scanner: scannerName,
                ruleId: finding.ruleId,
                severity: finding.severity,
                confidence: finding.confidence || 'medium',
                title: finding.title,
                description: finding.description,
                url: finding.filePath || scan.target.url,
                parameter: finding.metadata?.parameter,
                payload: finding.metadata?.payload,
                evidence: finding.metadata?.evidence,
                cweIds: finding.cweIds || [],
                cveIds: finding.cveIds || [],
                owaspIds: finding.owaspIds || [],
                references: finding.references || [],
                remediation: finding.fix?.description,
                fingerprint: finding.fingerprint,
                metadata: finding.metadata || {},
              },
            });

            allFindings.push(created);

            // Update severity counts
            const sev = finding.severity.toLowerCase();
            if (sev in severityCounts) {
              severityCounts[sev as keyof typeof severityCounts]++;
            }
          }

          this.logger.log(`${scannerName} found ${findings.length} findings`);
        } catch (err) {
          this.logger.error(`Scanner ${scannerName} failed: ${err}`);
        }
      }

      // Clean up work directory
      try {
        await fs.rm(workDir, { recursive: true, force: true });
      } catch {
        // Ignore cleanup errors
      }

      const duration = Math.floor((Date.now() - startTime) / 1000);

      // Update scan with results
      await this.prisma.penTestScan.update({
        where: { id: scanId },
        data: {
          status: 'completed',
          completedAt: new Date(),
          duration,
          findingsCount: allFindings.length,
          criticalCount: severityCounts.critical,
          highCount: severityCounts.high,
          mediumCount: severityCounts.medium,
          lowCount: severityCounts.low,
          infoCount: severityCounts.info,
        },
      });

      this.logger.log(`Scan ${scanId} completed with ${allFindings.length} findings`);
    } catch (error) {
      const duration = Math.floor((Date.now() - startTime) / 1000);

      await this.prisma.penTestScan.update({
        where: { id: scanId },
        data: {
          status: 'failed',
          completedAt: new Date(),
          duration,
          errorMessage: error instanceof Error ? error.message : String(error),
        },
      });

      this.logger.error(`Scan ${scanId} failed: ${error}`);
      throw error;
    }
  }

  // ============ TWO-PHASE SCANNING ============

  /**
   * Run a two-phase scan: discovery phase followed by deep phase
   */
  async runTwoPhase(tenantId: string, targetId: string, scanners?: string[]) {
    // Verify target exists
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id: targetId, tenantId },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    const selectedScanners = scanners || ['nuclei', 'nikto', 'sslyze'];

    // Phase 1: Create discovery scan
    const discoveryScan = await this.prisma.penTestScan.create({
      data: {
        tenantId,
        targetId,
        scanners: selectedScanners,
        scanPhase: 'discovery',
        status: 'pending',
        config: {},
      },
    });

    this.logger.log(`Starting two-phase scan: discovery phase ${discoveryScan.id}`);

    // Execute discovery phase
    const discoveryFindings = await this.executePhase(discoveryScan.id, tenantId, 'discovery', []);

    // Extract detected technologies from discovery findings
    const detectedTechnologies = this.extractTechnologies(discoveryFindings);

    // Update discovery scan with detected technologies
    await this.prisma.penTestScan.update({
      where: { id: discoveryScan.id },
      data: { detectedTechnologies },
    });

    this.logger.log(`Discovery phase complete. Detected technologies: ${detectedTechnologies.join(', ')}`);

    // Phase 2: Create deep scan (child of discovery)
    const deepScan = await this.prisma.penTestScan.create({
      data: {
        tenantId,
        targetId,
        scanners: selectedScanners,
        scanPhase: 'deep',
        parentScanId: discoveryScan.id,
        detectedTechnologies,
        status: 'pending',
        config: { detectedTechnologies },
      },
    });

    this.logger.log(`Starting deep phase ${deepScan.id}`);

    // Execute deep phase with detected technologies
    const deepFindings = await this.executePhase(deepScan.id, tenantId, 'deep', detectedTechnologies);

    // Combine and deduplicate findings
    const allFindings = [...discoveryFindings, ...deepFindings];
    const deduplicatedFindings = this.deduplicateFindings(allFindings);

    this.logger.log(`Two-phase scan complete. Total findings: ${allFindings.length}, Deduplicated: ${deduplicatedFindings.length}`);

    return {
      discoveryPhase: {
        scanId: discoveryScan.id,
        findingsCount: discoveryFindings.length,
        detectedTechnologies,
      },
      deepPhase: {
        scanId: deepScan.id,
        findingsCount: deepFindings.length,
        parentScanId: discoveryScan.id,
      },
      summary: {
        totalFindings: allFindings.length,
        uniqueFindings: deduplicatedFindings.length,
        duplicatesRemoved: allFindings.length - deduplicatedFindings.length,
      },
    };
  }

  /**
   * Execute a single phase of a scan
   */
  private async executePhase(
    scanId: string,
    tenantId: string,
    phase: 'discovery' | 'deep',
    detectedTechnologies: string[],
  ) {
    const scan = await this.prisma.penTestScan.findFirst({
      where: { id: scanId, tenantId },
      include: { target: true },
    });

    if (!scan) {
      throw new Error('Scan not found');
    }

    // Update status to running
    await this.prisma.penTestScan.update({
      where: { id: scanId },
      data: {
        status: 'running',
        startedAt: new Date(),
      },
    });

    const startTime = Date.now();
    const allFindings: any[] = [];
    const severityCounts = { critical: 0, high: 0, medium: 0, low: 0, info: 0 };

    try {
      const workDir = path.join(os.tmpdir(), `pentest-${scanId}`);
      await fs.mkdir(workDir, { recursive: true });

      for (const scannerName of scan.scanners) {
        const scanner = this.scanners.get(scannerName);
        if (!scanner) continue;

        try {
          const isAvailable = await scanner.isAvailable();
          if (!isAvailable) continue;

          this.logger.log(`[${phase}] Running ${scannerName} against ${scan.target.url}`);

          const context = {
            workDir,
            timeout: phase === 'discovery' ? 180000 : 300000, // 3 min discovery, 5 min deep
            config: {
              targetUrls: [scan.target.url],
              scanPhase: phase,
              detectedTechnologies: phase === 'deep' ? detectedTechnologies : [],
              ...(scan.config as object || {}),
            },
          };

          const output = await scanner.scan(context);
          const findings = await scanner.parseOutput(output);

          for (const finding of findings) {
            const created = await this.prisma.penTestFinding.create({
              data: {
                scanId,
                tenantId,
                scanner: scannerName,
                ruleId: finding.ruleId,
                severity: finding.severity,
                confidence: finding.confidence || 'medium',
                title: finding.title,
                description: finding.description,
                url: finding.filePath || scan.target.url,
                parameter: finding.metadata?.parameter,
                payload: finding.metadata?.payload,
                evidence: finding.metadata?.evidence,
                cweIds: finding.cweIds || [],
                cveIds: finding.cveIds || [],
                owaspIds: finding.owaspIds || [],
                references: finding.references || [],
                remediation: finding.fix?.description,
                fingerprint: finding.fingerprint,
                metadata: { ...finding.metadata, phase },
              },
            });

            allFindings.push(created);

            const sev = finding.severity.toLowerCase();
            if (sev in severityCounts) {
              severityCounts[sev as keyof typeof severityCounts]++;
            }
          }

          this.logger.log(`[${phase}] ${scannerName} found ${findings.length} findings`);
        } catch (err) {
          this.logger.error(`[${phase}] Scanner ${scannerName} failed: ${err}`);
        }
      }

      try {
        await fs.rm(workDir, { recursive: true, force: true });
      } catch {
        // Ignore cleanup errors
      }

      const duration = Math.floor((Date.now() - startTime) / 1000);

      await this.prisma.penTestScan.update({
        where: { id: scanId },
        data: {
          status: 'completed',
          completedAt: new Date(),
          duration,
          findingsCount: allFindings.length,
          criticalCount: severityCounts.critical,
          highCount: severityCounts.high,
          mediumCount: severityCounts.medium,
          lowCount: severityCounts.low,
          infoCount: severityCounts.info,
        },
      });

      return allFindings;
    } catch (error) {
      const duration = Math.floor((Date.now() - startTime) / 1000);

      await this.prisma.penTestScan.update({
        where: { id: scanId },
        data: {
          status: 'failed',
          completedAt: new Date(),
          duration,
          errorMessage: error instanceof Error ? error.message : String(error),
        },
      });

      throw error;
    }
  }

  /**
   * Extract technology names from discovery phase findings
   */
  private extractTechnologies(findings: any[]): string[] {
    const techs = new Set<string>();
    const techPatterns = [
      /apache/i, /nginx/i, /wordpress/i, /tomcat/i, /iis/i,
      /php/i, /nodejs?/i, /spring/i, /joomla/i, /drupal/i,
      /jenkins/i, /gitlab/i, /grafana/i, /kubernetes/i, /docker/i,
      /mysql/i, /postgres/i, /redis/i, /mongodb/i,
    ];

    for (const finding of findings) {
      // Check title and description
      const text = `${finding.title || ''} ${finding.description || ''} ${finding.ruleId || ''}`;

      for (const pattern of techPatterns) {
        const match = text.match(pattern);
        if (match) {
          techs.add(match[0].toLowerCase());
        }
      }

      // Check metadata
      if (finding.metadata?.extracted) {
        for (const extracted of finding.metadata.extracted) {
          for (const pattern of techPatterns) {
            if (typeof extracted === 'string' && pattern.test(extracted)) {
              const match = extracted.match(pattern);
              if (match) techs.add(match[0].toLowerCase());
            }
          }
        }
      }
    }

    return Array.from(techs);
  }

  /**
   * Deduplicate findings based on CVE/CWE + endpoint + scanner
   * Keeps highest severity, merges evidence
   */
  deduplicateFindings(findings: any[]): any[] {
    const findingMap = new Map<string, any>();

    for (const finding of findings) {
      // Generate dedup key
      const keyParts = [
        finding.cveIds?.[0] || finding.cweIds?.[0] || finding.title,
        finding.url || finding.filePath,
        finding.scanner,
      ].filter(Boolean);

      const key = keyParts.join('::').toLowerCase();

      const existing = findingMap.get(key);
      if (!existing) {
        findingMap.set(key, { ...finding });
      } else {
        // Merge: keep higher severity
        const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
        const existingSeverity = severityOrder.indexOf(existing.severity?.toLowerCase() || 'info');
        const newSeverity = severityOrder.indexOf(finding.severity?.toLowerCase() || 'info');

        if (newSeverity < existingSeverity) {
          existing.severity = finding.severity;
        }

        // Merge descriptions
        if (finding.description && finding.description !== existing.description) {
          existing.description = `${existing.description}\n\n---\n\n${finding.description}`;
        }

        // Merge evidence arrays
        if (finding.evidence) {
          existing.evidence = [...(existing.evidence || []), ...(Array.isArray(finding.evidence) ? finding.evidence : [finding.evidence])];
        }
      }
    }

    return Array.from(findingMap.values());
  }
}
