import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { ConfigService } from '@nestjs/config';
import {
  CreateTargetDto,
  UpdateTargetDto,
  CreateScanDto,
  UpdateFindingStatusDto,
  TargetQueryDto,
  ScanQueryDto,
  FindingQueryDto,
} from './dto';
import { SqlmapScanner, SSLyzeScanner, NiktoScanner, NucleiScanner } from '../scanners/pentest';
import { LocalExecutorService } from '../scanners/execution';
import * as path from 'path';
import * as fs from 'fs/promises';
import * as os from 'os';

@Injectable()
export class PenTestService {
  private readonly logger = new Logger(PenTestService.name);
  private readonly scanners: Map<string, any>;

  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ConfigService,
    private readonly executor: LocalExecutorService,
  ) {
    // Initialize scanners
    this.scanners = new Map();
    this.scanners.set('sqlmap', new SqlmapScanner(this.executor, this.configService));
    this.scanners.set('sslyze', new SSLyzeScanner(this.executor, this.configService));
    this.scanners.set('nikto', new NiktoScanner(this.executor, this.configService));
    this.scanners.set('nuclei', new NucleiScanner(this.executor, this.configService));
  }

  // ============ TARGETS ============

  async getTargets(tenantId: string, query: TargetQueryDto) {
    const where: any = { tenantId };

    if (query.projectId) {
      where.projectId = query.projectId;
    }
    if (query.type) {
      where.type = query.type;
    }
    if (query.isActive !== undefined) {
      where.isActive = query.isActive;
    }

    const targets = await this.prisma.penTestTarget.findMany({
      where,
      include: {
        scans: {
          take: 1,
          orderBy: { createdAt: 'desc' },
          select: {
            id: true,
            status: true,
            findingsCount: true,
            criticalCount: true,
            highCount: true,
            completedAt: true,
          },
        },
        _count: {
          select: { scans: true },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    return targets.map(target => ({
      ...target,
      lastScan: target.scans[0] || null,
      scanCount: target._count.scans,
      scans: undefined,
      _count: undefined,
    }));
  }

  async getTarget(tenantId: string, id: string) {
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id, tenantId },
      include: {
        scans: {
          orderBy: { createdAt: 'desc' },
          take: 10,
          include: {
            _count: {
              select: { findings: true },
            },
          },
        },
      },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    return target;
  }

  async createTarget(tenantId: string, dto: CreateTargetDto) {
    return this.prisma.penTestTarget.create({
      data: {
        tenantId,
        name: dto.name,
        url: dto.url,
        type: dto.type || 'web',
        description: dto.description,
        authConfig: dto.authConfig ? JSON.parse(JSON.stringify(dto.authConfig)) : undefined,
        headers: dto.headers ? JSON.parse(JSON.stringify(dto.headers)) : {},
        projectId: dto.projectId,
      },
    });
  }

  async updateTarget(tenantId: string, id: string, dto: UpdateTargetDto) {
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id, tenantId },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    const updateData: any = { ...dto };
    if (dto.authConfig) {
      updateData.authConfig = JSON.parse(JSON.stringify(dto.authConfig));
    }
    if (dto.headers) {
      updateData.headers = JSON.parse(JSON.stringify(dto.headers));
    }

    return this.prisma.penTestTarget.update({
      where: { id },
      data: updateData,
    });
  }

  async deleteTarget(tenantId: string, id: string) {
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id, tenantId },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    await this.prisma.penTestTarget.delete({ where: { id } });
    return { success: true };
  }

  // ============ SCANS ============

  async getScans(tenantId: string, query: ScanQueryDto) {
    const where: any = { tenantId };

    if (query.targetId) {
      where.targetId = query.targetId;
    }
    if (query.status) {
      where.status = query.status;
    }

    return this.prisma.penTestScan.findMany({
      where,
      include: {
        target: {
          select: {
            id: true,
            name: true,
            url: true,
            type: true,
          },
        },
        _count: {
          select: { findings: true },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async getScan(tenantId: string, id: string) {
    const scan = await this.prisma.penTestScan.findFirst({
      where: { id, tenantId },
      include: {
        target: true,
        findings: {
          orderBy: [
            { severity: 'asc' },
            { createdAt: 'desc' },
          ],
        },
      },
    });

    if (!scan) {
      throw new NotFoundException('Scan not found');
    }

    return scan;
  }

  async createScan(tenantId: string, dto: CreateScanDto) {
    // Verify target exists and belongs to tenant
    const target = await this.prisma.penTestTarget.findFirst({
      where: { id: dto.targetId, tenantId },
    });

    if (!target) {
      throw new NotFoundException('Target not found');
    }

    // Validate scanners
    const validScanners = ['sqlmap', 'sslyze', 'nikto', 'zap', 'nuclei'];
    const invalidScanners = dto.scanners.filter(s => !validScanners.includes(s));
    if (invalidScanners.length > 0) {
      throw new BadRequestException(`Invalid scanners: ${invalidScanners.join(', ')}`);
    }

    // Create scan record
    const scan = await this.prisma.penTestScan.create({
      data: {
        tenantId,
        targetId: dto.targetId,
        scanners: dto.scanners,
        config: dto.config ? JSON.parse(JSON.stringify(dto.config)) : {},
        status: 'pending',
      },
      include: {
        target: true,
      },
    });

    // Start scan asynchronously
    this.executeScan(scan.id, tenantId).catch(err => {
      this.logger.error(`Scan ${scan.id} failed: ${err.message}`);
    });

    return scan;
  }

  async cancelScan(tenantId: string, id: string) {
    const scan = await this.prisma.penTestScan.findFirst({
      where: { id, tenantId },
    });

    if (!scan) {
      throw new NotFoundException('Scan not found');
    }

    if (scan.status === 'completed' || scan.status === 'failed') {
      throw new BadRequestException('Cannot cancel completed or failed scan');
    }

    await this.prisma.penTestScan.update({
      where: { id },
      data: {
        status: 'cancelled',
        completedAt: new Date(),
      },
    });

    return { success: true };
  }

  // ============ FINDINGS ============

  async getFindings(tenantId: string, query: FindingQueryDto) {
    const where: any = { tenantId };

    if (query.scanId) {
      where.scanId = query.scanId;
    }
    if (query.targetId) {
      where.scan = { targetId: query.targetId };
    }
    if (query.severity) {
      where.severity = query.severity;
    }
    if (query.status) {
      where.status = query.status;
    }
    if (query.scanner) {
      where.scanner = query.scanner;
    }

    return this.prisma.penTestFinding.findMany({
      where,
      include: {
        scan: {
          select: {
            id: true,
            target: {
              select: {
                id: true,
                name: true,
                url: true,
              },
            },
          },
        },
      },
      orderBy: [
        { severity: 'asc' },
        { createdAt: 'desc' },
      ],
    });
  }

  async getFinding(tenantId: string, id: string) {
    const finding = await this.prisma.penTestFinding.findFirst({
      where: { id, tenantId },
      include: {
        scan: {
          include: {
            target: true,
          },
        },
      },
    });

    if (!finding) {
      throw new NotFoundException('Finding not found');
    }

    return finding;
  }

  async updateFindingStatus(tenantId: string, id: string, dto: UpdateFindingStatusDto, userId: string) {
    const finding = await this.prisma.penTestFinding.findFirst({
      where: { id, tenantId },
    });

    if (!finding) {
      throw new NotFoundException('Finding not found');
    }

    const updatedMetadata = {
      ...(typeof finding.metadata === 'object' && finding.metadata !== null ? finding.metadata : {}),
      notes: dto.notes,
    };

    return this.prisma.penTestFinding.update({
      where: { id },
      data: {
        status: dto.status,
        verifiedAt: new Date(),
        verifiedBy: userId,
        metadata: updatedMetadata,
      },
    });
  }

  // ============ SCANNER AVAILABILITY ============

  async getScannerStatus() {
    const status: Record<string, { available: boolean; version: string | null }> = {};

    for (const [name, scanner] of this.scanners) {
      try {
        const available = await scanner.isAvailable();
        let version: string | null = null;
        if (available) {
          try {
            version = await scanner.getVersion();
          } catch {
            // Version check may fail even if available
          }
        }
        status[name] = { available, version };
      } catch {
        status[name] = { available: false, version: null };
      }
    }

    // Add placeholder for ZAP (requires Java)
    status['zap'] = { available: false, version: null };

    return status;
  }

  // ============ SCAN EXECUTION ============

  private async executeScan(scanId: string, tenantId: string) {
    const scan = await this.prisma.penTestScan.findFirst({
      where: { id: scanId, tenantId },
      include: { target: true },
    });

    if (!scan) {
      throw new Error('Scan not found');
    }

    // Update status to running
    await this.prisma.penTestScan.update({
      where: { id: scanId },
      data: {
        status: 'running',
        startedAt: new Date(),
      },
    });

    // Update target lastScanAt
    await this.prisma.penTestTarget.update({
      where: { id: scan.targetId },
      data: { lastScanAt: new Date() },
    });

    const startTime = Date.now();
    const allFindings: any[] = [];
    const severityCounts = { critical: 0, high: 0, medium: 0, low: 0, info: 0 };

    try {
      // Create temp work directory
      const workDir = path.join(os.tmpdir(), `pentest-${scanId}`);
      await fs.mkdir(workDir, { recursive: true });

      // Run each selected scanner
      for (const scannerName of scan.scanners) {
        const scanner = this.scanners.get(scannerName);
        if (!scanner) {
          this.logger.warn(`Scanner ${scannerName} not found, skipping`);
          continue;
        }

        try {
          const isAvailable = await scanner.isAvailable();
          if (!isAvailable) {
            this.logger.warn(`Scanner ${scannerName} not available, skipping`);
            continue;
          }

          this.logger.log(`Running ${scannerName} against ${scan.target.url}`);

          // Prepare scan context
          const context = {
            workDir,
            timeout: 300000, // 5 minutes per scanner
            config: {
              targetUrls: [scan.target.url],
              ...(scan.config as object || {}),
            },
          };

          // Run scan
          const output = await scanner.scan(context);

          // Parse results
          const findings = await scanner.parseOutput(output);

          // Add findings to database
          for (const finding of findings) {
            const created = await this.prisma.penTestFinding.create({
              data: {
                scanId,
                tenantId,
                scanner: scannerName,
                ruleId: finding.ruleId,
                severity: finding.severity,
                confidence: finding.confidence || 'medium',
                title: finding.title,
                description: finding.description,
                url: finding.filePath || scan.target.url,
                parameter: finding.metadata?.parameter,
                payload: finding.metadata?.payload,
                evidence: finding.metadata?.evidence,
                cweIds: finding.cweIds || [],
                cveIds: finding.cveIds || [],
                owaspIds: finding.owaspIds || [],
                references: finding.references || [],
                remediation: finding.fix?.description,
                fingerprint: finding.fingerprint,
                metadata: finding.metadata || {},
              },
            });

            allFindings.push(created);

            // Update severity counts
            const sev = finding.severity.toLowerCase();
            if (sev in severityCounts) {
              severityCounts[sev as keyof typeof severityCounts]++;
            }
          }

          this.logger.log(`${scannerName} found ${findings.length} findings`);
        } catch (err) {
          this.logger.error(`Scanner ${scannerName} failed: ${err}`);
        }
      }

      // Clean up work directory
      try {
        await fs.rm(workDir, { recursive: true, force: true });
      } catch {
        // Ignore cleanup errors
      }

      const duration = Math.floor((Date.now() - startTime) / 1000);

      // Update scan with results
      await this.prisma.penTestScan.update({
        where: { id: scanId },
        data: {
          status: 'completed',
          completedAt: new Date(),
          duration,
          findingsCount: allFindings.length,
          criticalCount: severityCounts.critical,
          highCount: severityCounts.high,
          mediumCount: severityCounts.medium,
          lowCount: severityCounts.low,
          infoCount: severityCounts.info,
        },
      });

      this.logger.log(`Scan ${scanId} completed with ${allFindings.length} findings`);
    } catch (error) {
      const duration = Math.floor((Date.now() - startTime) / 1000);

      await this.prisma.penTestScan.update({
        where: { id: scanId },
        data: {
          status: 'failed',
          completedAt: new Date(),
          duration,
          errorMessage: error instanceof Error ? error.message : String(error),
        },
      });

      this.logger.error(`Scan ${scanId} failed: ${error}`);
      throw error;
    }
  }
}
