import { Injectable, Logger } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';

export interface SbomPackage {
  name: string;
  version: string;
  type: 'npm' | 'pypi' | 'maven' | 'nuget' | 'go' | 'cargo' | 'gem' | 'composer';
  purl?: string;
  licenses?: string[];
  supplier?: string;
}

export interface CveMatch {
  cveId: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'unknown';
  cvssScore?: number;
  cvssVector?: string;
  description: string;
  publishedDate: string;
  fixedVersion?: string;
  vulnerableRange?: string;
  references: string[];
  cweIds: string[];
  isKEV: boolean;
  epssScore?: number;
}

export interface PackageVulnerability {
  package: SbomPackage;
  vulnerabilities: CveMatch[];
  riskScore: number;
  hasKEV: boolean;
  fixAvailable: boolean;
}

export interface SbomAnalysisResult {
  analyzedAt: string;
  totalPackages: number;
  vulnerablePackages: number;
  vulnerabilities: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  kevCount: number;
  packageVulnerabilities: PackageVulnerability[];
  summary: {
    riskScore: number;
    riskLevel: 'critical' | 'high' | 'medium' | 'low' | 'clean';
    topRisks: string[];
    recommendations: string[];
  };
}

@Injectable()
export class SbomCveMatcherService {
  private readonly logger = new Logger(SbomCveMatcherService.name);
  private kevCache: Map<string, any> = new Map();
  private kevLastFetch: Date | null = null;

  constructor(private readonly httpService: HttpService) {}

  async analyzeSbom(packages: SbomPackage[]): Promise<SbomAnalysisResult> {
    const analyzedAt = new Date().toISOString();
    const packageVulnerabilities: PackageVulnerability[] = [];
    const vulnCounts = { critical: 0, high: 0, medium: 0, low: 0 };
    let kevCount = 0;

    // Refresh KEV cache if needed
    await this.refreshKEVCache();

    // Process packages in parallel batches
    const batchSize = 20;
    for (let i = 0; i < packages.length; i += batchSize) {
      const batch = packages.slice(i, i + batchSize);
      const batchResults = await Promise.all(
        batch.map(pkg => this.findVulnerabilitiesForPackage(pkg))
      );

      for (const result of batchResults) {
        if (result.vulnerabilities.length > 0) {
          packageVulnerabilities.push(result);

          for (const vuln of result.vulnerabilities) {
            vulnCounts[vuln.severity as keyof typeof vulnCounts]++;
            if (vuln.isKEV) kevCount++;
          }
        }
      }

      // Rate limit between batches
      if (i + batchSize < packages.length) {
        await this.delay(500);
      }
    }

    // Sort by risk score
    packageVulnerabilities.sort((a, b) => b.riskScore - a.riskScore);

    // Calculate summary
    const riskScore = this.calculateOverallRiskScore(packageVulnerabilities, vulnCounts, kevCount);
    const riskLevel = this.getRiskLevel(riskScore);
    const topRisks = this.identifyTopRisks(packageVulnerabilities);
    const recommendations = this.generateRecommendations(packageVulnerabilities, vulnCounts, kevCount);

    return {
      analyzedAt,
      totalPackages: packages.length,
      vulnerablePackages: packageVulnerabilities.length,
      vulnerabilities: vulnCounts,
      kevCount,
      packageVulnerabilities,
      summary: {
        riskScore,
        riskLevel,
        topRisks,
        recommendations,
      },
    };
  }

  async findVulnerabilitiesForPackage(pkg: SbomPackage): Promise<PackageVulnerability> {
    const vulnerabilities: CveMatch[] = [];
    let hasKEV = false;
    let fixAvailable = false;

    try {
      // Query OSV for vulnerabilities
      const osvVulns = await this.queryOSV(pkg);
      vulnerabilities.push(...osvVulns);

      // Check KEV status for each CVE
      for (const vuln of vulnerabilities) {
        if (this.isInKEV(vuln.cveId)) {
          vuln.isKEV = true;
          hasKEV = true;
        }
        if (vuln.fixedVersion) {
          fixAvailable = true;
        }
      }

      // Query EPSS for exploitation probability
      await this.enrichWithEPSS(vulnerabilities);

    } catch (error: any) {
      this.logger.error(`Failed to find vulnerabilities for ${pkg.name}@${pkg.version}: ${error.message}`);
    }

    const riskScore = this.calculatePackageRiskScore(vulnerabilities, hasKEV);

    return {
      package: pkg,
      vulnerabilities,
      riskScore,
      hasKEV,
      fixAvailable,
    };
  }

  private async queryOSV(pkg: SbomPackage): Promise<CveMatch[]> {
    try {
      const ecosystem = this.getOSVEcosystem(pkg.type);
      if (!ecosystem) {
        return [];
      }

      const response = await firstValueFrom(
        this.httpService.post('https://api.osv.dev/v1/query', {
          package: {
            name: pkg.name,
            ecosystem,
          },
          version: pkg.version,
        })
      );

      const vulns = response.data.vulns || [];
      return vulns.map((vuln: any) => this.mapOSVToCveMatch(vuln));
    } catch (error: any) {
      if (error.response?.status !== 404) {
        this.logger.warn(`OSV query failed for ${pkg.name}: ${error.message}`);
      }
      return [];
    }
  }

  private getOSVEcosystem(pkgType: string): string | null {
    const ecosystemMap: Record<string, string> = {
      npm: 'npm',
      pypi: 'PyPI',
      maven: 'Maven',
      nuget: 'NuGet',
      go: 'Go',
      cargo: 'crates.io',
      gem: 'RubyGems',
      composer: 'Packagist',
    };
    return ecosystemMap[pkgType] || null;
  }

  private mapOSVToCveMatch(vuln: any): CveMatch {
    const cveId = vuln.aliases?.find((a: string) => a.startsWith('CVE-')) || vuln.id;
    const severity = this.mapSeverity(vuln.severity?.[0]?.score || vuln.database_specific?.severity);

    // Find fixed version
    const affected = vuln.affected?.[0];
    const fixedRange = affected?.ranges?.find((r: any) =>
      r.events?.some((e: any) => e.fixed)
    );
    const fixedVersion = fixedRange?.events?.find((e: any) => e.fixed)?.fixed;

    // Get vulnerable range
    const vulnerableRange = affected?.versions?.join(', ') ||
      affected?.ranges?.map((r: any) =>
        r.events?.map((e: any) => Object.entries(e).map(([k, v]) => `${k}:${v}`).join(' ')).join(' ')
      ).join(', ');

    return {
      cveId,
      severity,
      cvssScore: vuln.severity?.[0]?.score,
      cvssVector: vuln.severity?.[0]?.type === 'CVSS_V3' ? vuln.severity?.[0]?.score?.toString() : undefined,
      description: vuln.summary || vuln.details?.substring(0, 500),
      publishedDate: vuln.published,
      fixedVersion,
      vulnerableRange,
      references: vuln.references?.map((r: any) => r.url) || [],
      cweIds: vuln.database_specific?.cwe_ids || [],
      isKEV: false,
      epssScore: undefined,
    };
  }

  private mapSeverity(score: number | string | undefined): 'critical' | 'high' | 'medium' | 'low' | 'unknown' {
    if (typeof score === 'number') {
      if (score >= 9.0) return 'critical';
      if (score >= 7.0) return 'high';
      if (score >= 4.0) return 'medium';
      if (score > 0) return 'low';
    }
    if (typeof score === 'string') {
      const lower = score.toLowerCase();
      if (lower === 'critical') return 'critical';
      if (lower === 'high') return 'high';
      if (lower === 'medium' || lower === 'moderate') return 'medium';
      if (lower === 'low') return 'low';
    }
    return 'unknown';
  }

  private async refreshKEVCache(): Promise<void> {
    // Refresh every hour
    if (this.kevLastFetch && Date.now() - this.kevLastFetch.getTime() < 3600000) {
      return;
    }

    try {
      const response = await firstValueFrom(
        this.httpService.get('https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json')
      );

      this.kevCache.clear();
      for (const vuln of response.data.vulnerabilities || []) {
        this.kevCache.set(vuln.cveID, vuln);
      }
      this.kevLastFetch = new Date();
      this.logger.log(`KEV cache refreshed with ${this.kevCache.size} entries`);
    } catch (error: any) {
      this.logger.error(`Failed to refresh KEV cache: ${error.message}`);
    }
  }

  private isInKEV(cveId: string): boolean {
    return this.kevCache.has(cveId);
  }

  private async enrichWithEPSS(vulnerabilities: CveMatch[]): Promise<void> {
    const cveIds = vulnerabilities
      .filter(v => v.cveId.startsWith('CVE-'))
      .map(v => v.cveId);

    if (cveIds.length === 0) return;

    try {
      const response = await firstValueFrom(
        this.httpService.get('https://api.first.org/data/v1/epss', {
          params: { cve: cveIds.join(',') },
        })
      );

      const epssData = response.data.data || [];
      const epssMap = new Map(epssData.map((d: any) => [d.cve, parseFloat(d.epss)]));

      for (const vuln of vulnerabilities) {
        if (epssMap.has(vuln.cveId)) {
          vuln.epssScore = epssMap.get(vuln.cveId) as number;
        }
      }
    } catch (error: any) {
      this.logger.warn(`Failed to fetch EPSS data: ${error.message}`);
    }
  }

  private calculatePackageRiskScore(vulnerabilities: CveMatch[], _hasKEV: boolean): number {
    if (vulnerabilities.length === 0) return 0;

    let score = 0;
    const severityWeights = { critical: 10, high: 7, medium: 4, low: 1, unknown: 2 };

    for (const vuln of vulnerabilities) {
      score += severityWeights[vuln.severity];

      // Boost for KEV
      if (vuln.isKEV) {
        score += 20;
      }

      // Boost for high EPSS
      if (vuln.epssScore && vuln.epssScore > 0.5) {
        score += vuln.epssScore * 10;
      }

      // Boost for CVSS score
      if (vuln.cvssScore) {
        score += vuln.cvssScore;
      }
    }

    return Math.min(100, Math.round(score));
  }

  private calculateOverallRiskScore(
    packageVulns: PackageVulnerability[],
    vulnCounts: Record<string, number>,
    kevCount: number
  ): number {
    if (packageVulns.length === 0) return 0;

    let score = 0;

    // Weight by severity counts
    score += vulnCounts.critical * 15;
    score += vulnCounts.high * 8;
    score += vulnCounts.medium * 3;
    score += vulnCounts.low * 1;

    // Major boost for KEV
    score += kevCount * 25;

    // Factor in package risk scores
    const avgPackageRisk = packageVulns.reduce((sum, p) => sum + p.riskScore, 0) / packageVulns.length;
    score += avgPackageRisk * 0.5;

    return Math.min(100, Math.round(score));
  }

  private getRiskLevel(score: number): 'critical' | 'high' | 'medium' | 'low' | 'clean' {
    if (score >= 80) return 'critical';
    if (score >= 50) return 'high';
    if (score >= 25) return 'medium';
    if (score > 0) return 'low';
    return 'clean';
  }

  private identifyTopRisks(packageVulns: PackageVulnerability[]): string[] {
    const risks: string[] = [];

    // KEV vulnerabilities first
    const kevPackages = packageVulns.filter(p => p.hasKEV);
    for (const pkg of kevPackages.slice(0, 3)) {
      const kevVuln = pkg.vulnerabilities.find(v => v.isKEV);
      if (kevVuln) {
        risks.push(`${pkg.package.name}@${pkg.package.version}: ${kevVuln.cveId} (KEV - actively exploited)`);
      }
    }

    // Critical vulnerabilities
    const criticalPackages = packageVulns.filter(p =>
      p.vulnerabilities.some(v => v.severity === 'critical') && !p.hasKEV
    );
    for (const pkg of criticalPackages.slice(0, 3)) {
      const critVuln = pkg.vulnerabilities.find(v => v.severity === 'critical');
      if (critVuln && risks.length < 5) {
        risks.push(`${pkg.package.name}@${pkg.package.version}: ${critVuln.cveId} (Critical)`);
      }
    }

    // High EPSS
    const highEPSS = packageVulns
      .flatMap(p => p.vulnerabilities.map(v => ({ pkg: p.package, vuln: v })))
      .filter(item => item.vuln.epssScore && item.vuln.epssScore > 0.7)
      .sort((a, b) => (b.vuln.epssScore || 0) - (a.vuln.epssScore || 0));

    for (const item of highEPSS.slice(0, 2)) {
      if (risks.length < 7) {
        risks.push(`${item.pkg.name}@${item.pkg.version}: ${item.vuln.cveId} (EPSS: ${((item.vuln.epssScore || 0) * 100).toFixed(1)}%)`);
      }
    }

    return risks;
  }

  private generateRecommendations(
    packageVulns: PackageVulnerability[],
    vulnCounts: Record<string, number>,
    kevCount: number
  ): string[] {
    const recommendations: string[] = [];

    if (kevCount > 0) {
      recommendations.push(`URGENT: ${kevCount} package(s) have Known Exploited Vulnerabilities. Patch immediately.`);
    }

    if (vulnCounts.critical > 0) {
      recommendations.push(`${vulnCounts.critical} critical vulnerabilities found. Prioritize patching these packages.`);
    }

    // Packages with available fixes
    const fixablePackages = packageVulns.filter(p => p.fixAvailable);
    if (fixablePackages.length > 0) {
      recommendations.push(`${fixablePackages.length} vulnerable packages have available updates.`);

      // List specific upgrades for top risks
      const topFixable = fixablePackages
        .filter(p => p.hasKEV || p.vulnerabilities.some(v => v.severity === 'critical'))
        .slice(0, 3);

      for (const pkg of topFixable) {
        const fixedVersions = pkg.vulnerabilities
          .filter(v => v.fixedVersion)
          .map(v => v.fixedVersion);
        const latestFix = fixedVersions.sort().reverse()[0];
        if (latestFix) {
          recommendations.push(`Upgrade ${pkg.package.name} from ${pkg.package.version} to ${latestFix}`);
        }
      }
    }

    if (vulnCounts.high > 5) {
      recommendations.push('Consider a security audit of your dependency supply chain.');
    }

    if (packageVulns.length > 10) {
      recommendations.push('Implement automated dependency scanning in CI/CD pipeline.');
    }

    return recommendations;
  }

  // Parse SBOM from different formats
  parseSBOM(content: string, format: 'cyclonedx' | 'spdx' | 'auto' = 'auto'): SbomPackage[] {
    let detectedFormat = format;

    if (format === 'auto') {
      if (content.includes('bomFormat') || content.includes('CycloneDX')) {
        detectedFormat = 'cyclonedx';
      } else if (content.includes('spdxVersion') || content.includes('SPDX')) {
        detectedFormat = 'spdx';
      } else {
        throw new Error('Unable to detect SBOM format');
      }
    }

    const parsed = JSON.parse(content);

    if (detectedFormat === 'cyclonedx') {
      return this.parseCycloneDX(parsed);
    } else if (detectedFormat === 'spdx') {
      return this.parseSPDX(parsed);
    }

    throw new Error(`Unsupported SBOM format: ${detectedFormat}`);
  }

  private parseCycloneDX(sbom: any): SbomPackage[] {
    const packages: SbomPackage[] = [];

    for (const component of sbom.components || []) {
      const pkg: SbomPackage = {
        name: component.name,
        version: component.version,
        type: this.detectPackageType(component.purl, component.type),
        purl: component.purl,
        licenses: component.licenses?.map((l: any) => l.license?.id || l.license?.name),
        supplier: component.supplier?.name,
      };
      packages.push(pkg);
    }

    return packages;
  }

  private parseSPDX(sbom: any): SbomPackage[] {
    const packages: SbomPackage[] = [];

    for (const pkg of sbom.packages || []) {
      // Skip the document package
      if (pkg.SPDXID === 'SPDXRef-DOCUMENT') continue;

      const purl = pkg.externalRefs?.find((r: any) => r.referenceType === 'purl')?.referenceLocator;

      const parsedPkg: SbomPackage = {
        name: pkg.name,
        version: pkg.versionInfo,
        type: this.detectPackageType(purl),
        purl,
        licenses: pkg.licenseConcluded ? [pkg.licenseConcluded] : undefined,
        supplier: pkg.supplier,
      };
      packages.push(parsedPkg);
    }

    return packages;
  }

  private detectPackageType(purl?: string, componentType?: string): SbomPackage['type'] {
    if (purl) {
      if (purl.startsWith('pkg:npm/')) return 'npm';
      if (purl.startsWith('pkg:pypi/')) return 'pypi';
      if (purl.startsWith('pkg:maven/')) return 'maven';
      if (purl.startsWith('pkg:nuget/')) return 'nuget';
      if (purl.startsWith('pkg:golang/')) return 'go';
      if (purl.startsWith('pkg:cargo/')) return 'cargo';
      if (purl.startsWith('pkg:gem/')) return 'gem';
      if (purl.startsWith('pkg:composer/')) return 'composer';
    }

    if (componentType) {
      const typeMap: Record<string, SbomPackage['type']> = {
        library: 'npm',
        framework: 'npm',
      };
      if (typeMap[componentType]) return typeMap[componentType];
    }

    return 'npm'; // Default
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
